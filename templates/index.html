<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Argus Dynamics - SENTRY Dashboard</title>
    <link rel="icon" type="image/x-icon" href="/images/Argus_Light.ico" media="(prefers-color-scheme: light)">
    <link rel="icon" type="image/x-icon" href="/images/Argus_Dark.ico" media="(prefers-color-scheme: dark)">
    <link rel="stylesheet" href="/styles/index.css">
</head>
<body>
    <!-- Login Modal -->
    <div id="loginModal" class="login-modal hidden">
        <div class="login-container">
            <div class="login-header">
                <div class="login-logo-container">
                    <img src="images/Argus_Light.png" alt="Argus Dynamics Logo" class="login-logo">
                </div>
                <h1>SENTRY UAS Dashboard</h1>
                <p>Please log in to continue</p>
            </div>
            <form id="loginForm" class="login-form">
                <div class="form-group">
                    <label for="username">Username</label>
                    <input type="text" id="username" name="username" placeholder="Enter username" required>
                </div>
                <div class="form-group">
                    <label for="password">Password</label>
                    <input type="password" id="password" name="password" placeholder="Enter password" required>
                </div>
                <div class="form-group checkbox">
                    <input type="checkbox" id="rememberMe" name="rememberMe">
                    <label for="rememberMe">Remember me</label>
                </div>
                <button type="submit" class="login-button">Sign In</button>
                <div id="loginError" class="login-error hidden"></div>
            </form>
        </div>
    </div>
    <div id="settingsModal" class="settings-modal hidden" aria-hidden="true">
        <div class="settings-container">
            <div class="settings-header">
                <div>
                    <h2>Settings</h2>
                    <p>Customize your dashboard experience</p>
                </div>
                <button type="button" id="settingsCloseBtn" class="settings-close">Close</button>
            </div>
            <form id="settingsForm" class="settings-form">
                <div class="settings-section">
                    <h3>System</h3>
                    <div class="settings-row">
                        <label class="settings-label" for="setting-latency-rate">Latency polling rate (ms)</label>
                        <input type="number" id="setting-latency-rate" min="200" max="5000" step="50">
                    </div>
                    <div class="settings-row">
                        <label class="settings-label" for="setting-status-rate">Status update interval (ms)</label>
                        <input type="number" id="setting-status-rate" min="2000" max="120000" step="500">
                    </div>
                </div>
                <div class="settings-section">
                    <h3>Home screen tiles</h3>
                    <p class="settings-hint" data-tiles-hint></p>
                    <div class="settings-tiles-columns">
                        <div class="settings-tile-column">
                            <h5 data-tile-column-title="active"></h5>
                            <div id="settings-tiles-active" class="settings-drag-list settings-tile-list" data-tiles-active></div>
                        </div>
                        <div class="settings-tile-column">
                            <h5 data-tile-column-title="inactive"></h5>
                            <div id="settings-tiles-inactive" class="settings-drag-list settings-tile-list" data-tiles-inactive></div>
                        </div>
                    </div>
                </div>
                <div class="settings-section">
                    <h3>Camera function buttons</h3>
                    <div class="settings-camera-tabs" data-camera-tabs="cam0">
                        <h4>Pilot camera</h4>
                        <p class="settings-hint" data-settings-hint></p>
                        <div class="settings-camera-columns">
                            <div class="settings-camera-column">
                                <h5 data-camera-column-title="active"></h5>
                                <div class="settings-drag-list" data-camera-active></div>
                            </div>
                            <div class="settings-camera-column">
                                <h5 data-camera-column-title="inactive"></h5>
                                <div class="settings-drag-list" data-camera-inactive></div>
                            </div>
                        </div>
                    </div>
                    <div class="settings-camera-tabs" data-camera-tabs="cam1">
                        <h4>Landing camera</h4>
                        <p class="settings-hint" data-settings-hint></p>
                        <div class="settings-camera-columns">
                            <div class="settings-camera-column">
                                <h5 data-camera-column-title="active"></h5>
                                <div class="settings-drag-list" data-camera-active></div>
                            </div>
                            <div class="settings-camera-column">
                                <h5 data-camera-column-title="inactive"></h5>
                                <div class="settings-drag-list" data-camera-inactive></div>
                            </div>
                        </div>
                    </div>
                    <div class="settings-camera-tabs" data-camera-tabs="hq">
                        <h4>High quality camera</h4>
                        <p class="settings-hint" data-settings-hint></p>
                        <div class="settings-camera-columns">
                            <div class="settings-camera-column">
                                <h5 data-camera-column-title="active"></h5>
                                <div class="settings-drag-list" data-camera-active></div>
                            </div>
                            <div class="settings-camera-column">
                                <h5 data-camera-column-title="inactive"></h5>
                                <div class="settings-drag-list" data-camera-inactive></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="settings-actions">
                    <button type="button" id="settingsLogoutBtn" class="settings-logout">Logout</button>
                    <div class="settings-action-group">
                        <button type="button" id="settingsReloadWsBtn" class="settings-tertiary">Reload connections</button>
                        <button type="button" id="settingsCancelBtn" class="settings-secondary">Cancel</button>
                        <button type="submit" id="settingsSaveBtn" class="settings-primary">Save settings</button>
                    </div>
                </div>
            </form>
        </div>
    </div>
    <div id="banner">
        <div class="banner-left">
            <img src="images/Argus_Dark.png" alt="Argus Dynamics Logo">
            <h1>SENTRY UAS Dashboard</h1>
        </div>
        <div class="banner-right">
            <div class="main-status">
                <span id="main-status-dot" class="status-dot {{ 'on' if main_online else 'off' }}"></span>
                <span>System Status</span>
            </div>
            <div id="guidedModeToolbar" class="guided-mode-toolbar" aria-label="Guided mode controls">
                <span class="guided-mode-toolbar-label">Guided Mode</span>
                <label class="switch guided-mode-switch" for="guidedModeSwitch" aria-label="Guided mode switch">
                    <input type="checkbox" id="guidedModeSwitch" aria-label="Enable guided mode">
                    <span class="slider"></span>
                </label>
                <div id="guidedAltitudeWrap" class="guided-altitude-wrap" aria-hidden="true">
                    <label for="guidedAltitudeInput">Alt (m)</label>
                    <input type="number" id="guidedAltitudeInput" min="1" max="500" step="1" value="20" inputmode="decimal">
                </div>
            </div>
            <div id="banner-slot"></div>
            <button id="settingsBtn" class="settings-button" aria-label="Open settings">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M12 8.5a3.5 3.5 0 1 0 0 7 3.5 3.5 0 0 0 0-7Zm9 3.5a7.1 7.1 0 0 0-.1-1l2.1-1.6-2-3.4-2.5 1a7.7 7.7 0 0 0-1.7-1l-.4-2.7h-4l-.4 2.7a7.7 7.7 0 0 0-1.7 1l-2.5-1-2 3.4 2.1 1.6a7.1 7.1 0 0 0 0 2l-2.1 1.6 2 3.4 2.5-1a7.7 7.7 0 0 0 1.7 1l.4 2.7h4l.4-2.7a7.7 7.7 0 0 0 1.7-1l2.5 1 2-3.4-2.1-1.6c.1-.3.1-.6.1-1Z" fill="currentColor"></path>
                </svg>
            </button>
        </div>
    </div>

    <div class="grid">
        <div class="card" data-card data-card-id="cam0">
            <div class="card-header" data-header>
                <span id="cam0-status-dot" class="status-dot {{ 'on' if cam0_online else 'off' }}"></span>
                <h2>Pilot Camera</h2>
                <button class="minimize" data-minimize>Minimize</button>
            </div>
            <div class="media">
                <img id="stream_cam0" src="{{ url_for('video_feed_cam0') }}">
            </div>
            <div class="camera-function-rail" data-function-rail data-camera-id="cam0" aria-label="Pilot camera functions"></div>
            <div class="desc">Front facing camera for BVLOS piloting</div>
        </div>

        <div class="card" data-card data-card-id="cam1">
            <div class="card-header" data-header>
                <span id="cam1-status-dot" class="status-dot {{ 'on' if cam1_online else 'off' }}"></span>
                <h2>Landing Camera</h2>
                <button class="minimize" data-minimize>Minimize</button>
            </div>
            <div class="media">
                <img id="stream_cam1" src="{{ url_for('video_feed_cam1') }}">
            </div>
            <div class="camera-function-rail" data-function-rail data-camera-id="cam1" aria-label="Landing camera functions"></div>
            <div class="desc">Infrared camera for landing assistance</div>
        </div>

        <div class="card" data-card data-card-id="hq">
            <div class="card-header" data-header>
                <span id="hq-status-dot" class="status-dot {{ 'on' if hq_online else 'off' }}"></span>
                <h2>High Quality Camera</h2>
                <div class="guided-mode-toolbar hq-cv-toolbar" data-hq-cv-switch aria-label="High quality camera CV mode selector">
                    <div class="guided-mode-toolbar-label">CV Mode</div>
                    <div class="hq-cv-mode-buttons" role="group" aria-label="CV processing mode">
                        <button type="button" class="hq-cv-mode-btn" data-hq-cv-mode="none" aria-pressed="false">No CV</button>
                        <button type="button" class="hq-cv-mode-btn" data-hq-cv-mode="landing_mode" aria-pressed="false">Landing</button>
                        <button type="button" class="hq-cv-mode-btn" data-hq-cv-mode="target_tracking" aria-pressed="false">Target</button>
                    </div>
                    <div class="hq-tt-model-row" data-hq-tt-model-row>
                        <label class="hq-tt-model-label" for="hqTtModelSelect">Model</label>
                        <select id="hqTtModelSelect" class="hq-tt-model-select" data-hq-tt-model-select aria-label="Target tracking model selector">
                            <option value="best8np2">best8np2</option>
                            <option value="best_stg1">best_stg1</option>
                        </select>
                    </div>
                </div>
                <button class="minimize" data-minimize>Minimize</button>
            </div>
            <div class="media">
                <img id="stream_hq" src="{{ url_for('video_feed_hq') }}">
            </div>
            <div class="camera-function-rail" data-function-rail data-camera-id="hq" aria-label="High quality camera functions"></div>
            <div class="desc">High Quality camera for detailed imaging (Gimbal)</div>
        </div>

        <div class="card" data-card data-card-id="map">
            <div class="card-header" data-header>
                <span id="map-status-dot" class="status-dot {{ 'on' if map_online else 'off' }}"></span>
                <h2>GPS Map</h2>
                <button class="minimize" data-minimize>Minimize</button>
            </div>
            <div class="media_map">
                <div class="map-container">{{ map_html|safe }}</div>
            </div>
            <div id="map-function-rail" class="camera-function-rail map-function-rail" aria-label="Map functions"></div>
            <div class="desc_map">GPS Location of SENTRY</div>
        </div>

        <div class="card latency-card" data-card data-card-id="latency">
            <div class="card-header" data-header>
                <span id="latency-status-dot" class="status-dot off"></span>
                <h2>Latency Monitoring</h2>
                <button class="minimize" data-minimize>Minimize</button>
            </div>
            <div class="media latency-content">
                <div class="latency-dashboard">
                    <div class="latency-group" data-latency-group="cam0">
                        <div class="latency-group-header">
                            <div class="latency-group-title">
                                <h3>Pilot Camera</h3>
                                <p class="latency-subtitle">Capture → Screen</p>
                            </div>
                            <div class="latency-group-total">
                                <span id="cam0-total-latency" class="latency-total-value">--</span>
                                <span class="latency-unit">ms</span>
                            </div>
                        </div>
                        <div class="latency-e2e-bar">
                            <div id="cam0-e2e-bar" class="latency-e2e-fill"></div>
                        </div>
                        <div class="latency-breakdown">
                            <div class="latency-breakdown-row" id="cam0-uplink-row">
                                <div class="latency-breakdown-label">
                                    <span>Uplink (capture → gateway)</span>
                                </div>
                                <div class="latency-breakdown-metrics">
                                    <span id="cam0-uplink-latency" class="latency-value">--</span>
                                    <span class="latency-unit">ms</span>
                                </div>
                            </div>
                            <div class="latency-breakdown-row" id="cam0-processing-row">
                                <div class="latency-breakdown-label">
                                    <span>Gateway processing</span>
                                </div>
                                <div class="latency-breakdown-metrics">
                                    <span id="cam0-processing-latency" class="latency-value">--</span>
                                    <span class="latency-unit">ms</span>
                                </div>
                            </div>
                            <div class="latency-breakdown-row" id="cam0-delivery-row">
                                <div class="latency-breakdown-label">
                                    <span>Browser delivery + decode</span>
                                </div>
                                <div class="latency-breakdown-metrics">
                                    <span id="cam0-delivery-latency" class="latency-value">--</span>
                                    <span class="latency-unit">ms</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="latency-group" data-latency-group="cam1">
                        <div class="latency-group-header">
                            <div class="latency-group-title">
                                <h3>Landing Camera</h3>
                                <p class="latency-subtitle">Capture → Screen</p>
                            </div>
                            <div class="latency-group-total">
                                <span id="cam1-total-latency" class="latency-total-value">--</span>
                                <span class="latency-unit">ms</span>
                            </div>
                        </div>
                        <div class="latency-e2e-bar">
                            <div id="cam1-e2e-bar" class="latency-e2e-fill"></div>
                        </div>
                        <div class="latency-breakdown">
                            <div class="latency-breakdown-row" id="cam1-uplink-row">
                                <div class="latency-breakdown-label">
                                    <span>Uplink (capture → gateway)</span>
                                </div>
                                <div class="latency-breakdown-metrics">
                                    <span id="cam1-uplink-latency" class="latency-value">--</span>
                                    <span class="latency-unit">ms</span>
                                </div>
                            </div>
                            <div class="latency-breakdown-row" id="cam1-processing-row">
                                <div class="latency-breakdown-label">
                                    <span>Gateway processing</span>
                                </div>
                                <div class="latency-breakdown-metrics">
                                    <span id="cam1-processing-latency" class="latency-value">--</span>
                                    <span class="latency-unit">ms</span>
                                </div>
                            </div>
                            <div class="latency-breakdown-row" id="cam1-delivery-row">
                                <div class="latency-breakdown-label">
                                    <span>Browser delivery + decode</span>
                                </div>
                                <div class="latency-breakdown-metrics">
                                    <span id="cam1-delivery-latency" class="latency-value">--</span>
                                    <span class="latency-unit">ms</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="latency-group" data-latency-group="hq">
                        <div class="latency-group-header">
                            <div class="latency-group-title">
                                <h3>High Quality Camera</h3>
                                <p class="latency-subtitle">Capture → Screen</p>
                            </div>
                            <div class="latency-group-total">
                                <span id="hq-total-latency" class="latency-total-value">--</span>
                                <span class="latency-unit">ms</span>
                            </div>
                        </div>
                        <div class="latency-e2e-bar">
                            <div id="hq-e2e-bar" class="latency-e2e-fill"></div>
                        </div>
                        <div class="latency-breakdown">
                            <div class="latency-breakdown-row" id="hq-uplink-row">
                                <div class="latency-breakdown-label">
                                    <span>Uplink (capture → gateway)</span>
                                </div>
                                <div class="latency-breakdown-metrics">
                                    <span id="hq-uplink-latency" class="latency-value">--</span>
                                    <span class="latency-unit">ms</span>
                                </div>
                            </div>
                            <div class="latency-breakdown-row" id="hq-processing-row">
                                <div class="latency-breakdown-label">
                                    <span>Gateway processing</span>
                                </div>
                                <div class="latency-breakdown-metrics">
                                    <span id="hq-processing-latency" class="latency-value">--</span>
                                    <span class="latency-unit">ms</span>
                                </div>
                            </div>
                            <div class="latency-breakdown-row" id="hq-delivery-row">
                                <div class="latency-breakdown-label">
                                    <span>Browser delivery + decode</span>
                                </div>
                                <div class="latency-breakdown-metrics">
                                    <span id="hq-delivery-latency" class="latency-value">--</span>
                                    <span class="latency-unit">ms</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="latency-group" data-latency-group="telemetry">
                        <div class="latency-group-header">
                            <div class="latency-group-title">
                                <h3>MAVLink Telemetry</h3>
                                <p class="latency-subtitle">Sensor → Dashboard</p>
                            </div>
                            <div class="latency-group-total">
                                <span id="telemetry-total-latency" class="latency-total-value">--</span>
                                <span class="latency-unit">ms</span>
                            </div>
                        </div>
                        <div class="latency-e2e-bar">
                            <div id="telemetry-e2e-bar" class="latency-e2e-fill"></div>
                        </div>
                        <div class="latency-breakdown">
                            <div class="latency-breakdown-row" id="telemetry-uplink-row">
                                <div class="latency-breakdown-label">
                                    <span>Uplink (MAVLink → gateway)</span>
                                </div>
                                <div class="latency-breakdown-metrics">
                                    <span id="telemetry-uplink-latency" class="latency-value">--</span>
                                    <span class="latency-unit">ms</span>
                                </div>
                            </div>
                            <div class="latency-breakdown-row" id="telemetry-delivery-row">
                                <div class="latency-breakdown-label">
                                    <span>Browser delivery + parse</span>
                                </div>
                                <div class="latency-breakdown-metrics">
                                    <span id="telemetry-delivery-latency" class="latency-value">--</span>
                                    <span class="latency-unit">ms</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="latency-stats">
                        <div class="stat-item">
                            <span class="stat-label">Update Rate</span>
                            <span id="latency-update-rate" class="stat-value">--</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Last Update</span>
                            <span id="latency-last-update" class="stat-value">--</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="desc">End-to-end latency with component breakdown</div>
        </div>

        <div class="card mavlink-terminal-card" data-card data-card-id="mavlink_terminal">
            <div class="card-header" data-header>
                <span id="mavlink-terminal-status-dot" class="status-dot off"></span>
                <h2>MAVLink Terminal</h2>
                <button class="minimize" data-minimize>Minimize</button>
            </div>
            <div class="media mavlink-terminal-content">
                <div class="mavlink-terminal-shell">
                    <div class="mavlink-terminal-meta">
                        <span id="mavlink-terminal-endpoint">UDP endpoint: --</span>
                    </div>
                    <pre id="mavlink-terminal-output" class="mavlink-terminal-output">Waiting for pilot messages (PreArm, EKF, GPS)...</pre>
                </div>
            </div>
            <div class="desc">Mission Planner-style pilot messages (PreArm, EKF, GPS, arm state)</div>
        </div>

        <div class="card command-card" data-card data-card-id="commands">
            <div class="card-header" data-header>
                <span id="commands-status-dot" class="status-dot on"></span>
                <h2>SENTRY Controls</h2>
                <button class="minimize" data-minimize>Minimize</button>
            </div>
            <div class="media command-suite">
                <div class="command-grid compact-view" id="command-compact"></div>
                <div class="command-grid full-view" id="command-full"></div>
            </div>
            <div class="desc">Command switches for onboard functions and mission actions</div>
        </div>
    </div>

    <!-- Minimap overlay (bottom-right) - toggle button is now inside camera rails -->
    <div id="minimap" class="minimap" aria-hidden="true">
        <div class="minimap-bar" id="minimap-bar">
            <button type="button" id="minimapCenterBtn" class="minimap-control-btn" aria-label="Return minimap to center" title="Return to Center">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><circle cx="12" cy="12" r="3" fill="none" stroke="currentColor" stroke-width="2"></circle><circle cx="12" cy="12" r="9" fill="none" stroke="currentColor" stroke-width="2"></circle><line x1="12" y1="1" x2="12" y2="4" stroke="currentColor" stroke-width="2"></line><line x1="12" y1="20" x2="12" y2="23" stroke="currentColor" stroke-width="2"></line><line x1="1" y1="12" x2="4" y2="12" stroke="currentColor" stroke-width="2"></line><line x1="20" y1="12" x2="23" y2="12" stroke="currentColor" stroke-width="2"></line></svg>
            </button>
            <button type="button" id="minimapClearBtn" class="minimap-control-btn" aria-label="Clear markers" title="Clear Markers">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><polyline points="3 6 5 6 21 6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></polyline><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><line x1="10" y1="11" x2="10" y2="17" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line><line x1="14" y1="11" x2="14" y2="17" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line></svg>
            </button>
            <button type="button" id="minimapGuidedBtn" class="minimap-control-btn" aria-label="Toggle guided mode in minimap" aria-pressed="false" title="Guided Mode">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><circle cx="12" cy="12" r="3" fill="none" stroke="currentColor" stroke-width="2"></circle><circle cx="12" cy="12" r="8" fill="none" stroke="currentColor" stroke-width="2"></circle><line x1="12" y1="2" x2="12" y2="5" stroke="currentColor" stroke-width="2"></line><line x1="12" y1="19" x2="12" y2="22" stroke="currentColor" stroke-width="2"></line><line x1="2" y1="12" x2="5" y2="12" stroke="currentColor" stroke-width="2"></line><line x1="19" y1="12" x2="22" y2="12" stroke="currentColor" stroke-width="2"></line></svg>
            </button>
            <button type="button" id="minimapEnlargeBtn" class="minimap-control-btn" aria-label="Enlarge minimap" aria-pressed="false" title="Enlarge Minimap">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><polyline points="15 3 21 3 21 9" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></polyline><polyline points="9 21 3 21 3 15" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></polyline><line x1="21" y1="3" x2="14" y2="10" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line><line x1="3" y1="21" x2="10" y2="14" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line></svg>
            </button>
        </div>
        <div class="minimap-content" id="minimap-content">
            <!-- iframe cloned here when available; no text per design -->
        </div>
    </div>

    <script type="application/json" id="camera-function-tabs-data">{{ camera_function_tabs | tojson }}</script>
    <script type="application/json" id="user-settings-data">{{ user_settings | tojson }}</script>

    <script>
        // ===== GLOBAL CONFIGURATION =====
        const CAMERA_FUNCTION_TABS_DATA_ID = 'camera-function-tabs-data';
        const USER_SETTINGS_DATA_ID = 'user-settings-data';
        const DEFAULT_CAMERA_FUNCTION_TABS = JSON.parse(document.getElementById(CAMERA_FUNCTION_TABS_DATA_ID)?.textContent || '{}');
        const SETTINGS_CAMERA_ACTIVE_TITLE = 'Active';
        const SETTINGS_CAMERA_INACTIVE_TITLE = 'Inactive';
        const SETTINGS_CAMERA_HINT_TEXT = 'Drag functions between Active and Inactive. The Active order matches the camera rail.';
        const SETTINGS_CAMERA_EMPTY_TEXT = 'Drop here';
        const SETTINGS_TILE_ACTIVE_TITLE = 'Active';
        const SETTINGS_TILE_INACTIVE_TITLE = 'Inactive';
        const SETTINGS_TILE_HINT_TEXT = 'Drag tiles between Active and Inactive. The Active order matches the home screen layout.';
        const SETTINGS_TILE_EMPTY_TEXT = 'Drop here';
        const TILE_DEFS = [
            { id: 'cam0', label: 'Pilot camera' },
            { id: 'cam1', label: 'Landing camera' },
            { id: 'hq', label: 'High quality camera' },
            { id: 'map', label: 'GPS map' },
            { id: 'latency', label: 'Latency monitoring', isWide: true },
            { id: 'mavlink_terminal', label: 'MAVLink terminal', isWide: true },
            { id: 'commands', label: 'SENTRY controls' }
        ];
        const DEFAULT_TILE_ORDER = TILE_DEFS.map(tile => tile.id);
        const DEFAULT_USER_SETTINGS = {
            latency_polling_rate_ms: 500,
            status_update_interval_ms: 30000,
            visible_tiles: {
                cam0: true,
                cam1: true,
                hq: true,
                map: true,
                latency: true,
                mavlink_terminal: true,
                commands: true
            },
            camera_function_tabs: DEFAULT_CAMERA_FUNCTION_TABS,
            tile_order: DEFAULT_TILE_ORDER
        };
        const SERVER_USER_SETTINGS = JSON.parse(document.getElementById(USER_SETTINGS_DATA_ID)?.textContent || 'null');
        const LATENCY_SNAPSHOT_TIMEOUT_MS = 1500;
        const MAVLINK_TERMINAL_ENDPOINT = '/api/mavlink_messages';
        const MAVLINK_TERMINAL_POLL_MS = 500;
        const MAVLINK_TERMINAL_SCROLL_BOTTOM_THRESHOLD_PX = 24;
        const MAP_RAIL_COMMAND_ID = 'drop_gps_pin';
        const MAP_GUIDED_MODE_LABEL = 'Guided Mode';
        const MINIMAP_ENLARGE_ACTIVE_CLASS = 'is-large';
        const MAP_GUIDED_MODE_MESSAGE_TYPE = 'sentry_guided_map_dblclick';
        const MAP_GUIDED_GOTO_ENDPOINT = '/api/guided_goto';
        const MAP_GUIDED_GOTO_TIMEOUT_MS = 5000;
        const MAP_GUIDED_DEFAULT_ALT_M = 20;
        const MAP_GUIDED_MIN_ALT_M = 1;
        const MAP_GUIDED_MAX_ALT_M = 500;
        const MAP_GUIDED_ALT_STEP_M = 1;
        const LATENCY_THRESHOLD_GOOD_MS = 100;
        const LATENCY_THRESHOLD_WARNING_MS = 300;
        const LATENCY_HEADER_FRAME_TS = 'X-Frame-Ts';
        const LATENCY_HEADER_NETWORK_MS = 'X-Network-Ms';
        const LATENCY_HEADER_PROCESSING_MS = 'X-Processing-Ms';
        const LATENCY_VIDEO_SNAPSHOT_ENDPOINTS = {
            cam0: '/api/snapshot_cam0',
            cam1: '/api/snapshot_cam1',
            hq: '/api/snapshot_hq'
        };
        const CAMERA_RAIL_BLOCKED_COMMAND_IDS = new Set(['landing_mode']);
        const HQ_CV_MODE_ENDPOINT = '/api/hq_cv_mode';
        const HQ_TARGET_SELECTION_ENDPOINT = '/api/hq_target_selection';
        const HQ_TARGET_TRACKING_MODEL_ENDPOINT = '/api/hq_target_tracking_model';
        const HQ_TARGET_TRACKING_STATUS_ENDPOINT = '/api/hq_target_tracking_status';
        const HQ_TARGET_TRACKING_STATUS_POLL_MS = 1500;
        const HQ_CV_DEFAULT_MODE = '';

        let userSettings = mergeSettings(DEFAULT_USER_SETTINGS, SERVER_USER_SETTINGS || {});
        let cameraFunctionTabs = userSettings.camera_function_tabs || DEFAULT_CAMERA_FUNCTION_TABS;
        let latencyUpdateIntervalMs = userSettings.latency_polling_rate_ms || DEFAULT_USER_SETTINGS.latency_polling_rate_ms;
        let statusUpdateIntervalMs = userSettings.status_update_interval_ms || DEFAULT_USER_SETTINGS.status_update_interval_ms;
        let latencyIntervalId = null;
        let statusIntervalId = null;
        let mavlinkTerminalIntervalId = null;
        let hqCvMode = HQ_CV_DEFAULT_MODE;
        let hqTargetSelected = false;
        let hqTargetTrackId = null;
        let hqTrackingStatusText = '';
        let hqTargetTrackingModelKey = 'best8np2';
        let hqTargetTrackingModelOptions = [
            { key: 'best8np2', label: 'best8np2' },
            { key: 'best_stg1', label: 'best_stg1' }
        ];
        let guidedModeEnabled = false;
        let guidedModeAltitudeM = MAP_GUIDED_DEFAULT_ALT_M;
        let minimapLarge = false;
        
        // ===== GLOBAL DOM ELEMENTS =====
        const bannerSlot = document.getElementById('banner-slot');
        const bannerRight = document.querySelector('#banner .banner-right');
        const loginModal = document.getElementById('loginModal');
        const loginForm = document.getElementById('loginForm');
        const loginError = document.getElementById('loginError');
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsModal = document.getElementById('settingsModal');
        const settingsForm = document.getElementById('settingsForm');
        const settingsCloseBtn = document.getElementById('settingsCloseBtn');
        const settingsCancelBtn = document.getElementById('settingsCancelBtn');
        const settingsLogoutBtn = document.getElementById('settingsLogoutBtn');
        const settingsReloadWsBtn = document.getElementById('settingsReloadWsBtn');
        const guidedModeToolbarEl = document.getElementById('guidedModeToolbar');
        const guidedModeSwitchEl = document.getElementById('guidedModeSwitch');
        const guidedAltitudeWrapEl = document.getElementById('guidedAltitudeWrap');
        const guidedAltitudeInputEl = document.getElementById('guidedAltitudeInput');
        const minimapCenterBtnEl = document.getElementById('minimapCenterBtn');
        const minimapClearBtnEl = document.getElementById('minimapClearBtn');
        const minimapGuidedBtnEl = document.getElementById('minimapGuidedBtn');
        const minimapEnlargeBtnEl = document.getElementById('minimapEnlargeBtn');
        
        // ===== GLOBAL STATE =====
        let latencyState = {
            cam0: {
                network_ms: 0,
                processing_ms: 0,
                delivery_ms: 0,
                total_ms: 0,
                samples: 0,
                online: false
            },
            cam1: {
                network_ms: 0,
                processing_ms: 0,
                delivery_ms: 0,
                total_ms: 0,
                samples: 0,
                online: false
            },
            hq: {
                network_ms: 0,
                processing_ms: 0,
                delivery_ms: 0,
                capture_to_screen_ms: 0,
                total_ms: 0,
                samples: 0,
                online: false
            },
            telemetry: {
                uplink_ms: 0,
                delivery_ms: 0,
                total_ms: 0
            }
        };

        // ===== HELPER FUNCTIONS =====
        function getLatencyClass(latencyMs) {
            if (latencyMs <= 0) return '';
            if (latencyMs < LATENCY_THRESHOLD_GOOD_MS) return 'good';
            if (latencyMs < LATENCY_THRESHOLD_WARNING_MS) return 'warning';
            return 'critical';
        }

        function normalizeLatency(value) {
            return Number.isFinite(value) ? Math.max(0, value) : 0;
        }

        function updateStatusDot(elementId, isOnline) {
            const dot = document.getElementById(elementId);
            if (!dot) return;
            dot.classList.remove('on', 'off');
            dot.classList.add(isOnline ? 'on' : 'off');
        }

        function updateLatencyValue(elementId, value, applyClass = false) {
            const el = document.getElementById(elementId);
            if (!el) return;
            el.textContent = value > 0 ? value.toFixed(1) : '--';
            if (applyClass) {
                el.classList.remove('good', 'warning', 'critical');
                const cls = getLatencyClass(value);
                if (cls) el.classList.add(cls);
            }
        }

        function updateE2EBar(elementId, latencyMs, maxMs = 800) {
            const el = document.getElementById(elementId);
            if (!el) return;
            const width = Math.min(100, (latencyMs / maxMs) * 100);
            el.style.width = `${width}%`;
            el.classList.remove('good', 'warning', 'critical');
            const cls = getLatencyClass(latencyMs);
            if (cls) el.classList.add(cls);
        }

        async function fetchWithTimeout(url, options = {}, timeoutMs = 1500) {
            const controller = new AbortController();
            const timer = setTimeout(() => controller.abort(), timeoutMs);
            try {
                return await fetch(url, { ...options, signal: controller.signal });
            } finally {
                clearTimeout(timer);
            }
        }

        function mergeSettings(defaults, overrides) {
            const merged = { ...defaults, ...overrides };
            merged.visible_tiles = { ...defaults.visible_tiles, ...(overrides.visible_tiles || {}) };
            merged.camera_function_tabs = { ...defaults.camera_function_tabs, ...(overrides.camera_function_tabs || {}) };
            merged.tile_order = sanitizeTileOrder(overrides.tile_order || defaults.tile_order || DEFAULT_TILE_ORDER);
            return merged;
        }

        function sanitizeTileOrder(order) {
            const allowed = TILE_DEFS.map(tile => tile.id);
            const cleaned = [];
            const seen = new Set();
            if (Array.isArray(order)) {
                order.forEach(id => {
                    if (allowed.includes(id) && !seen.has(id)) {
                        cleaned.push(id);
                        seen.add(id);
                    }
                });
            }
            allowed.forEach(id => {
                if (!seen.has(id)) cleaned.push(id);
            });
            return cleaned;
        }

        function getTileDef(id) {
            return TILE_DEFS.find(tile => tile.id === id);
        }

        function getSessionToken() {
            return localStorage.getItem('sentryToken') || sessionStorage.getItem('sentryToken');
        }

        function applyTileVisibility(visibleTiles) {
            document.querySelectorAll('[data-card]').forEach(card => {
                const cardId = card.getAttribute('data-card-id');
                const isVisible = visibleTiles?.[cardId] !== false;
                card.classList.toggle('is-hidden', !isVisible);
            });
        }

        function applyTileOrder(tileOrder) {
            const grid = document.querySelector('.grid');
            if (!grid) return;
            const cardsById = {};
            grid.querySelectorAll('[data-card]').forEach(card => {
                const cardId = card.getAttribute('data-card-id');
                cardsById[cardId] = card;
            });
            const order = sanitizeTileOrder(tileOrder || DEFAULT_TILE_ORDER);
            order.forEach(id => {
                const card = cardsById[id];
                if (card) grid.appendChild(card);
            });
        }

        function startLatencyPolling() {
            if (latencyIntervalId) clearInterval(latencyIntervalId);
            latencyIntervalId = setInterval(refreshLatencyData, latencyUpdateIntervalMs);
        }

        function startStatusPolling() {
            if (statusIntervalId) clearInterval(statusIntervalId);
            statusIntervalId = setInterval(updateStatusDots, statusUpdateIntervalMs);
        }

        function startMavlinkTerminalPolling() {
            if (mavlinkTerminalIntervalId) clearInterval(mavlinkTerminalIntervalId);
            mavlinkTerminalIntervalId = setInterval(refreshMavlinkTerminal, MAVLINK_TERMINAL_POLL_MS);
        }

        function applySettingsToUI(settings) {
            userSettings = mergeSettings(DEFAULT_USER_SETTINGS, settings || {});
            cameraFunctionTabs = userSettings.camera_function_tabs || DEFAULT_CAMERA_FUNCTION_TABS;
            latencyUpdateIntervalMs = userSettings.latency_polling_rate_ms || DEFAULT_USER_SETTINGS.latency_polling_rate_ms;
            statusUpdateIntervalMs = userSettings.status_update_interval_ms || DEFAULT_USER_SETTINGS.status_update_interval_ms;
            applyTileVisibility(userSettings.visible_tiles);
            applyTileOrder(userSettings.tile_order);
            renderCameraFunctionTabs();
            startLatencyPolling();
            startStatusPolling();
        }

        async function reloadWebsocketConnections() {
            const token = getSessionToken();
            try {
                await fetch('/api/reload_websockets', {
                    method: 'POST',
                    headers: token ? { 'X-Session-Token': token } : {}
                });
            } catch (err) {
                console.error('Failed to reload websocket connections:', err);
            }

            executeOnIframe((iframe) => {
                try {
                    const win = iframe.contentWindow;
                    if (win && typeof win.reloadTelemetrySocket === 'function') {
                        win.reloadTelemetrySocket();
                    }
                } catch (err) {
                    console.warn('Failed to reload map telemetry socket:', err);
                }
            });
        }

        function openSettingsModal() {
            if (!settingsModal) return;
            if (!loginModal.classList.contains('hidden')) return;
            settingsModal.classList.remove('hidden');
            settingsModal.setAttribute('aria-hidden', 'false');
            document.body.style.overflow = 'hidden';
        }

        function closeSettingsModal() {
            if (!settingsModal) return;
            settingsModal.classList.add('hidden');
            settingsModal.setAttribute('aria-hidden', 'true');
            document.body.style.overflow = 'auto';
        }

        let draggedSettingsItem = null;

        function buildSettingsDragItem(def) {
            const item = document.createElement('div');
            item.className = 'settings-drag-item';
            item.setAttribute('draggable', 'true');
            item.dataset.commandId = def.id;
            item.innerHTML = `
                <span class="settings-drag-label">${def.label}</span>
                <span class="settings-drag-handle" aria-hidden="true">⋮⋮</span>
            `;

            item.addEventListener('dragstart', (e) => {
                draggedSettingsItem = item;
                item.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', def.id);
            });

            item.addEventListener('dragend', () => {
                item.classList.remove('dragging');
                document.querySelectorAll('.settings-drag-list.is-over').forEach(list => {
                    list.classList.remove('is-over');
                });
                draggedSettingsItem = null;
            });

            return item;
        }

        function buildSettingsTileItem(tile) {
            const item = document.createElement('div');
            item.className = 'settings-drag-item settings-tile-item';
            if (tile.isWide) item.classList.add('is-wide');
            item.setAttribute('draggable', 'true');
            item.dataset.tileId = tile.id;
            item.innerHTML = `
                <span class="settings-drag-label">${tile.label}</span>
                <span class="settings-drag-handle" aria-hidden="true">⋮⋮</span>
            `;

            item.addEventListener('dragstart', (e) => {
                draggedSettingsItem = item;
                item.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', tile.id);
            });

            item.addEventListener('dragend', () => {
                item.classList.remove('dragging');
                document.querySelectorAll('.settings-drag-list.is-over').forEach(list => {
                    list.classList.remove('is-over');
                });
                draggedSettingsItem = null;
            });

            return item;
        }

        function getSettingsDragAfterElement(listEl, y) {
            const draggableItems = [...listEl.querySelectorAll('.settings-drag-item:not(.dragging)')];
            return draggableItems.reduce(
                (closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = y - box.top - box.height / 2;
                    if (offset < 0 && offset > closest.offset) {
                        return { offset, element: child };
                    }
                    return closest;
                },
                { offset: Number.NEGATIVE_INFINITY, element: null }
            ).element;
        }

        function setupSettingsDragList(listEl) {
            listEl.addEventListener('dragover', (e) => {
                e.preventDefault();
                if (!draggedSettingsItem) return;
                const afterElement = getSettingsDragAfterElement(listEl, e.clientY);
                if (afterElement == null) {
                    listEl.appendChild(draggedSettingsItem);
                } else {
                    listEl.insertBefore(draggedSettingsItem, afterElement);
                }
                listEl.classList.add('is-over');
            });

            listEl.addEventListener('dragleave', () => {
                listEl.classList.remove('is-over');
            });

            listEl.addEventListener('drop', () => {
                listEl.classList.remove('is-over');
            });
        }

        function renderCameraSettingsLists(container, selectedIds) {
            const activeList = container.querySelector('[data-camera-active]');
            const inactiveList = container.querySelector('[data-camera-inactive]');
            if (!activeList || !inactiveList) return;

            const allCommandIds = COMMAND_DEFS
                .map(def => def.id)
                .filter(id => !CAMERA_RAIL_BLOCKED_COMMAND_IDS.has(id));
            const activeIds = (selectedIds || []).filter(id => allCommandIds.includes(id));
            const inactiveIds = allCommandIds.filter(id => !activeIds.includes(id));

            activeList.innerHTML = '';
            inactiveList.innerHTML = '';

            activeIds.forEach(id => {
                const def = getCommandDef(id);
                if (def) activeList.appendChild(buildSettingsDragItem(def));
            });

            inactiveIds.forEach(id => {
                const def = getCommandDef(id);
                if (def) inactiveList.appendChild(buildSettingsDragItem(def));
            });
        }

        function renderTileSettingsLists(merged) {
            const activeList = document.querySelector('[data-tiles-active]');
            const inactiveList = document.querySelector('[data-tiles-inactive]');
            if (!activeList || !inactiveList) return;

            const order = sanitizeTileOrder(merged.tile_order || DEFAULT_TILE_ORDER);
            const visibleTiles = merged.visible_tiles || {};

            activeList.innerHTML = '';
            inactiveList.innerHTML = '';

            order.forEach(id => {
                const tile = getTileDef(id);
                if (!tile) return;
                const target = visibleTiles?.[id] === false ? inactiveList : activeList;
                target.appendChild(buildSettingsTileItem(tile));
            });
        }

        function populateSettingsForm(settings) {
            const merged = mergeSettings(DEFAULT_USER_SETTINGS, settings || {});
            document.getElementById('setting-latency-rate').value = merged.latency_polling_rate_ms;
            document.getElementById('setting-status-rate').value = merged.status_update_interval_ms;

            renderTileSettingsLists(merged);

            document.querySelectorAll('[data-camera-tabs]').forEach(container => {
                const camId = container.getAttribute('data-camera-tabs');
                const selected = merged.camera_function_tabs?.[camId] || [];
                renderCameraSettingsLists(container, selected);
            });
        }

        function buildCameraSettingsOptions() {
            const tilesHint = document.querySelector('[data-tiles-hint]');
            if (tilesHint) tilesHint.textContent = SETTINGS_TILE_HINT_TEXT;

            document.querySelectorAll('[data-tile-column-title="active"]').forEach(title => {
                title.textContent = SETTINGS_TILE_ACTIVE_TITLE;
            });

            document.querySelectorAll('[data-tile-column-title="inactive"]').forEach(title => {
                title.textContent = SETTINGS_TILE_INACTIVE_TITLE;
            });

            const tilesActive = document.querySelector('[data-tiles-active]');
            const tilesInactive = document.querySelector('[data-tiles-inactive]');

            if (tilesActive) {
                tilesActive.dataset.emptyText = SETTINGS_TILE_EMPTY_TEXT;
                setupSettingsDragList(tilesActive);
            }

            if (tilesInactive) {
                tilesInactive.dataset.emptyText = SETTINGS_TILE_EMPTY_TEXT;
                setupSettingsDragList(tilesInactive);
            }

            document.querySelectorAll('[data-camera-tabs]').forEach(container => {
                const hintEl = container.querySelector('[data-settings-hint]');
                if (hintEl) hintEl.textContent = SETTINGS_CAMERA_HINT_TEXT;

                container.querySelectorAll('[data-camera-column-title="active"]').forEach(title => {
                    title.textContent = SETTINGS_CAMERA_ACTIVE_TITLE;
                });

                container.querySelectorAll('[data-camera-column-title="inactive"]').forEach(title => {
                    title.textContent = SETTINGS_CAMERA_INACTIVE_TITLE;
                });

                const activeList = container.querySelector('[data-camera-active]');
                const inactiveList = container.querySelector('[data-camera-inactive]');

                if (activeList) {
                    activeList.dataset.emptyText = SETTINGS_CAMERA_EMPTY_TEXT;
                    setupSettingsDragList(activeList);
                }

                if (inactiveList) {
                    inactiveList.dataset.emptyText = SETTINGS_CAMERA_EMPTY_TEXT;
                    setupSettingsDragList(inactiveList);
                }
            });
        }

        function collectSettingsFromForm() {
            const visibleTiles = {};
            const tileOrder = [];
            const activeTiles = document.querySelector('[data-tiles-active]');
            const inactiveTiles = document.querySelector('[data-tiles-inactive]');

            if (activeTiles) {
                activeTiles.querySelectorAll('.settings-drag-item[data-tile-id]').forEach(item => {
                    const tileId = item.getAttribute('data-tile-id');
                    tileOrder.push(tileId);
                    visibleTiles[tileId] = true;
                });
            }

            if (inactiveTiles) {
                inactiveTiles.querySelectorAll('.settings-drag-item[data-tile-id]').forEach(item => {
                    const tileId = item.getAttribute('data-tile-id');
                    tileOrder.push(tileId);
                    visibleTiles[tileId] = false;
                });
            }

            const cameraTabs = {};
            document.querySelectorAll('[data-camera-tabs]').forEach(container => {
                const camId = container.getAttribute('data-camera-tabs');
                const selected = [];
                const activeList = container.querySelector('[data-camera-active]');
                if (activeList) {
                    activeList.querySelectorAll('.settings-drag-item[data-command-id]').forEach(item => {
                        selected.push(item.getAttribute('data-command-id'));
                    });
                }
                cameraTabs[camId] = selected;
            });

            return {
                latency_polling_rate_ms: Number(document.getElementById('setting-latency-rate').value || DEFAULT_USER_SETTINGS.latency_polling_rate_ms),
                status_update_interval_ms: Number(document.getElementById('setting-status-rate').value || DEFAULT_USER_SETTINGS.status_update_interval_ms),
                visible_tiles: visibleTiles,
                camera_function_tabs: cameraTabs,
                tile_order: tileOrder
            };
        }

        async function loadUserSettings() {
            try {
                const token = getSessionToken();
                const res = await fetch('/api/settings', {
                    headers: token ? { 'X-Session-Token': token } : {}
                });
                if (!res.ok) return;
                const data = await res.json();
                applySettingsToUI(data);
                populateSettingsForm(data);
            } catch (err) {
                console.error('Failed to load settings:', err);
                applySettingsToUI(userSettings);
                populateSettingsForm(userSettings);
            }
        }

        // ===== LATENCY FUNCTIONS =====
        function updateLatencyGroup(groupId, components, forcedTotal = null) {
            const total = components.reduce((sum, item) => sum + item.value, 0);
            const resolvedTotal = Number.isFinite(forcedTotal) && forcedTotal > 0 ? forcedTotal : total;
            updateLatencyValue(`${groupId}-total-latency`, resolvedTotal, true);
            updateE2EBar(`${groupId}-e2e-bar`, resolvedTotal);

            components.forEach(item => {
                updateLatencyValue(`${groupId}-${item.key}-latency`, item.value);
            });

            return resolvedTotal;
        }

        function refreshLatencyUI() {
            const cam0Total = updateLatencyGroup('cam0', [
                { key: 'uplink', value: latencyState.cam0.network_ms },
                { key: 'processing', value: latencyState.cam0.processing_ms },
                { key: 'delivery', value: latencyState.cam0.delivery_ms }
            ]);
            const cam1Total = updateLatencyGroup('cam1', [
                { key: 'uplink', value: latencyState.cam1.network_ms },
                { key: 'processing', value: latencyState.cam1.processing_ms },
                { key: 'delivery', value: latencyState.cam1.delivery_ms }
            ]);
            const hqForcedTotal = latencyState.hq.capture_to_screen_ms > 0
                ? latencyState.hq.capture_to_screen_ms
                : null;
            const hqTotal = updateLatencyGroup('hq', [
                { key: 'uplink', value: latencyState.hq.network_ms },
                { key: 'processing', value: latencyState.hq.processing_ms },
                { key: 'delivery', value: latencyState.hq.delivery_ms }
            ], hqForcedTotal);
            const telemetryTotal = updateLatencyGroup('telemetry', [
                { key: 'uplink', value: latencyState.telemetry.uplink_ms },
                { key: 'delivery', value: latencyState.telemetry.delivery_ms }
            ]);

            latencyState.cam0.total_ms = cam0Total;
            latencyState.cam1.total_ms = cam1Total;
            latencyState.hq.total_ms = hqTotal;
            latencyState.telemetry.total_ms = telemetryTotal;

            const updateRateEl = document.getElementById('latency-update-rate');
            const lastUpdateEl = document.getElementById('latency-last-update');
            if (updateRateEl) updateRateEl.textContent = `${latencyUpdateIntervalMs}ms`;
            if (lastUpdateEl) lastUpdateEl.textContent = new Date().toLocaleTimeString();

            const hasData = cam0Total > 0 || cam1Total > 0 || hqTotal > 0 || telemetryTotal > 0;
            updateStatusDot('latency-status-dot', hasData);
        }

        async function fetchVideoLatency() {
            try {
                const response = await fetchWithTimeout('/api/video_latency', { cache: 'no-store' }, LATENCY_SNAPSHOT_TIMEOUT_MS);
                if (!response.ok) return;
                const data = await response.json();
                latencyState.cam0.network_ms = normalizeLatency(data.cam0_network_latency_ms);
                latencyState.cam1.network_ms = normalizeLatency(data.cam1_network_latency_ms);
                latencyState.hq.network_ms = normalizeLatency(data.hq_network_latency_ms);
                latencyState.cam0.processing_ms = normalizeLatency(data.cam0_processing_latency_ms);
                latencyState.cam1.processing_ms = normalizeLatency(data.cam1_processing_latency_ms);
                latencyState.hq.processing_ms = normalizeLatency(data.hq_processing_latency_ms);
                latencyState.cam0.samples = data.cam0_samples || 0;
                latencyState.cam1.samples = data.cam1_samples || 0;
                latencyState.hq.samples = data.hq_samples || 0;
                latencyState.cam0.online = Boolean(data.cam0_online);
                latencyState.cam1.online = Boolean(data.cam1_online);
                latencyState.hq.online = Boolean(data.hq_online);
            } catch (err) {
                console.error('Failed to fetch video latency:', err);
            }
        }

        async function fetchSnapshotLatency(camId) {
            const endpoint = LATENCY_VIDEO_SNAPSHOT_ENDPOINTS[camId];
            if (!endpoint || !latencyState[camId]) return;
            try {
                const start = performance.now();
                const response = await fetchWithTimeout(`${endpoint}?t=${Date.now()}`, { cache: 'no-store' }, LATENCY_SNAPSHOT_TIMEOUT_MS);
                if (!response.ok || response.status === 204) {
                    latencyState[camId].delivery_ms = 0;
                    return;
                }

                const blob = await response.blob();
                const img = new Image();
                const objectUrl = URL.createObjectURL(blob);
                img.src = objectUrl;
                try {
                    await img.decode();
                } catch (e) {
                    await new Promise(resolve => {
                        img.onload = resolve;
                        img.onerror = resolve;
                    });
                }
                URL.revokeObjectURL(objectUrl);
                const end = performance.now();
                const snapshotRoundtripMs = normalizeLatency(end - start);

                // For HQ, use frame timestamp headers to compute true capture->screen end-to-end latency.
                if (camId === 'hq') {
                    const frameTs = Number.parseFloat(response.headers.get(LATENCY_HEADER_FRAME_TS));
                    const headerNetworkMs = Number.parseFloat(response.headers.get(LATENCY_HEADER_NETWORK_MS));
                    const headerProcessingMs = Number.parseFloat(response.headers.get(LATENCY_HEADER_PROCESSING_MS));

                    if (Number.isFinite(frameTs) && frameTs > 0) {
                        const wallClockEndMs = Date.now();
                        const captureToScreenMs = normalizeLatency(wallClockEndMs - (frameTs * 1000));

                        // Prefer header values when present; default missing headers to 0
                        const netMs = (Number.isFinite(headerNetworkMs) && headerNetworkMs >= 0) ? normalizeLatency(headerNetworkMs) : 0;
                        const procMs = (Number.isFinite(headerProcessingMs) && headerProcessingMs >= 0) ? normalizeLatency(headerProcessingMs) : 0;

                        latencyState.hq.network_ms = netMs;
                        latencyState.hq.processing_ms = procMs;

                        latencyState.hq.capture_to_screen_ms = captureToScreenMs;
                        const residualDelivery = captureToScreenMs - netMs - procMs;
                        latencyState.hq.delivery_ms = normalizeLatency(residualDelivery);
                        return;
                    }

                    // Fallback path when headers are unavailable.
                    latencyState.hq.capture_to_screen_ms = 0;
                }

                latencyState[camId].delivery_ms = snapshotRoundtripMs;
            } catch (err) {
                latencyState[camId].delivery_ms = 0;
                if (camId === 'hq') {
                    latencyState.hq.capture_to_screen_ms = 0;
                }
            }
        }

        async function fetchTelemetryLatency() {
            try {
                const start = performance.now();
                const response = await fetchWithTimeout('/telemetry', { cache: 'no-store' }, LATENCY_SNAPSHOT_TIMEOUT_MS);
                if (!response.ok) return;
                const data = await response.json();
                const end = performance.now();
                latencyState.telemetry.uplink_ms = normalizeLatency(data.client_latency_ms);
                latencyState.telemetry.delivery_ms = normalizeLatency(end - start);
            } catch (err) {
                latencyState.telemetry.uplink_ms = 0;
                latencyState.telemetry.delivery_ms = 0;
            }
        }

        async function refreshLatencyData() {
            await Promise.allSettled([
                fetchVideoLatency(),
                fetchSnapshotLatency('cam0'),
                fetchSnapshotLatency('cam1'),
                fetchSnapshotLatency('hq'),
                fetchTelemetryLatency()
            ]);
            refreshLatencyUI();
        }
        
        // ===== STATUS UPDATE FUNCTIONS =====
        function updateStatusDots() {
            fetch('/api/status')
                .then(response => response.json())
                .then(status => {
                    updateStatusDot('main-status-dot', status.main_online);
                    updateStatusDot('cam0-status-dot', status.cam0_online);
                    updateStatusDot('cam1-status-dot', status.cam1_online);
                    updateStatusDot('hq-status-dot', status.hq_online);
                    updateStatusDot('map-status-dot', status.map_online);
                    updateStatusDot('mavlink-terminal-status-dot', status.mavlink_terminal_online);
                })
                .catch(err => console.error('Failed to fetch status:', err));
        }

        function renderMavlinkTerminal(data) {
            const outputEl = document.getElementById('mavlink-terminal-output');
            const endpointEl = document.getElementById('mavlink-terminal-endpoint');
            if (!outputEl) return;

            if (endpointEl) {
                const endpointText = data?.endpoint || '--';
                endpointEl.textContent = `UDP endpoint: ${endpointText}`;
            }

            const isNearBottom = (outputEl.scrollTop + outputEl.clientHeight) >= (outputEl.scrollHeight - MAVLINK_TERMINAL_SCROLL_BOTTOM_THRESHOLD_PX);
            const lines = Array.isArray(data?.messages)
                ? data.messages.map(item => item?.line).filter(Boolean)
                : [];

            if (lines.length === 0) {
                outputEl.textContent = 'Waiting for pilot messages (PreArm, EKF, GPS)...';
            } else {
                outputEl.textContent = lines.join('\n');
            }

            updateStatusDot('mavlink-terminal-status-dot', Boolean(data?.online));

            if (isNearBottom) {
                outputEl.scrollTop = outputEl.scrollHeight;
            }
        }

        async function refreshMavlinkTerminal() {
            try {
                const response = await fetchWithTimeout(MAVLINK_TERMINAL_ENDPOINT, { cache: 'no-store' }, LATENCY_SNAPSHOT_TIMEOUT_MS);
                if (!response.ok) return;
                const data = await response.json();
                renderMavlinkTerminal(data);
            } catch (err) {
                updateStatusDot('mavlink-terminal-status-dot', false);
            }
        }
        
        // ===== MAP CONTROL FUNCTIONS =====
        
        function getMapIframe() {
            const mapCard = document.querySelector('[data-card-id="map"]');
            return mapCard?.querySelector('iframe');
        }

        function executeOnIframe(callback) {
            const iframe = getMapIframe();
            if (!iframe) return;

            if (iframe.contentDocument?.readyState === 'complete') {
                callback(iframe);
            } else {
                iframe.addEventListener('load', () => callback(iframe), { once: true });
            }
        }

        function updateMapControls() {
            executeOnIframe((iframe) => {
                const doc = iframe.contentDocument || iframe.contentWindow?.document;
                if (!doc) return;
                
                const mapCard = document.querySelector('[data-card-id="map"]');
                const isExpanded = mapCard?.classList.contains('expanded');
                
                doc.querySelectorAll('.leaflet-control').forEach(el => {
                    el.style.display = isExpanded ? '' : 'none';
                });
                
                const resetBtn = doc.getElementById('reset-btn');
                if (resetBtn) resetBtn.style.display = isExpanded ? 'block' : 'none';

                const clearPinsBtn = doc.getElementById('clear-pins-btn');
                if (clearPinsBtn) clearPinsBtn.style.display = isExpanded ? 'block' : 'none';

                iframe.contentWindow?.setGuidedModeEnabled?.(guidedModeEnabled);
            });
        }

        function applyMapGuidedToggleUI() {
            if (guidedModeSwitchEl) {
                guidedModeSwitchEl.checked = guidedModeEnabled;
            }
            if (guidedAltitudeWrapEl) {
                guidedAltitudeWrapEl.classList.toggle('is-active', guidedModeEnabled);
                guidedAltitudeWrapEl.setAttribute('aria-hidden', guidedModeEnabled ? 'false' : 'true');
            }
            if (minimapGuidedBtnEl) {
                minimapGuidedBtnEl.classList.toggle('is-active', guidedModeEnabled);
                minimapGuidedBtnEl.setAttribute('aria-pressed', guidedModeEnabled ? 'true' : 'false');
            }
        }

        function updateGuidedToolbarVisibility() {
            const visible = isMapExpanded();
            if (!guidedModeToolbarEl) return;
            guidedModeToolbarEl.classList.toggle('is-visible', visible);
            guidedModeToolbarEl.setAttribute('aria-hidden', visible ? 'false' : 'true');
        }

        function attachGuidedToolbarToMapHeader(headerEl) {
            if (!guidedModeToolbarEl || !headerEl) return;
            const minimizeBtn = headerEl.querySelector('.minimize');
            if (minimizeBtn) {
                headerEl.insertBefore(guidedModeToolbarEl, minimizeBtn);
            } else {
                headerEl.appendChild(guidedModeToolbarEl);
            }
            guidedModeToolbarEl.classList.add('in-map-header');
        }

        function restoreGuidedToolbarToBanner() {
            if (!guidedModeToolbarEl || !bannerRight) return;
            if (guidedModeToolbarEl.parentElement !== bannerRight) {
                bannerRight.insertBefore(guidedModeToolbarEl, bannerSlot);
            }
            guidedModeToolbarEl.classList.remove('in-map-header');
        }

        function clampGuidedAltitude(value) {
            if (!Number.isFinite(value)) return MAP_GUIDED_DEFAULT_ALT_M;
            return Math.min(MAP_GUIDED_MAX_ALT_M, Math.max(MAP_GUIDED_MIN_ALT_M, value));
        }

        function getGuidedAltitudeValue() {
            const rawValue = Number(guidedAltitudeInputEl?.value ?? guidedModeAltitudeM);
            guidedModeAltitudeM = clampGuidedAltitude(rawValue);
            if (guidedAltitudeInputEl) {
                guidedAltitudeInputEl.value = String(guidedModeAltitudeM);
            }
            return guidedModeAltitudeM;
        }

        function setMapGuidedMode(enabled) {
            guidedModeEnabled = Boolean(enabled);
            applyMapGuidedToggleUI();
            callMapMethod('setGuidedModeEnabled', guidedModeEnabled);
            callMinimapMethod('setGuidedModeEnabled', guidedModeEnabled);
        }

        function isMapExpanded() {
            const mapCard = document.querySelector('[data-card-id="map"]');
            return Boolean(mapCard?.classList.contains('expanded'));
        }

        async function sendGuidedGoto(lat, lon) {
            const guidedAlt = getGuidedAltitudeValue();
            const sentTsMs = Date.now();

            // Show marker immediately so operator gets instant visual feedback.
            callMapMethod('addGuidedTargetMarker', lat, lon, guidedAlt, sentTsMs);
            callMinimapMethod('addGuidedTargetMarker', lat, lon, guidedAlt, sentTsMs);

            try {
                const response = await fetchWithTimeout(
                    MAP_GUIDED_GOTO_ENDPOINT,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ lat, lon, alt: guidedAlt })
                    },
                    MAP_GUIDED_GOTO_TIMEOUT_MS
                );

                if (!response.ok) {
                    return;
                }

                const data = await response.json();
                if (!data?.success) {
                    console.warn('Guided goto rejected by backend:', data?.message || 'unknown error');
                    return;
                }
            } catch (err) {
                console.error('Failed to send guided goto command:', err);
            }
        }

        function handleGuidedMapMessage(event) {
            const payload = event?.data;
            if (!payload || payload.type !== MAP_GUIDED_MODE_MESSAGE_TYPE) return;
            if (!guidedModeEnabled) return;

            const lat = Number(payload.lat);
            const lon = Number(payload.lon);
            if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;

            sendGuidedGoto(lat, lon);
        }

        // ===== MINIMAP (small persistent map) =====
        let minimapOpen = false;

        function updateMinimapVisibility() {
            const expandedCard = document.querySelector('.card.expanded');
            const showTab = expandedCard && ['cam0', 'cam1', 'hq'].includes(expandedCard.getAttribute('data-card-id'));
            // minimap toggle is rendered inside the camera function rail; when the
            // expanded card is not a camera we close the minimap overlay.
            if (!showTab) {
                minimapOpen = false;
                const mm = document.getElementById('minimap');
                if (mm) mm.classList.remove('open');
                const content = document.getElementById('minimap-content');
                if (content) content.querySelectorAll('iframe').forEach(n => n.remove());
            }
        }

        function showMinimap() {
            minimapOpen = true;
            const mm = document.getElementById('minimap');
            if (mm) mm.classList.add('open');

            const content = document.getElementById('minimap-content');
            if (!content) return;
            content.querySelectorAll('iframe, .map-clone').forEach(n => n.remove());

            const iframe = getMapIframe();
            if (iframe && iframe.src) {
                try {
                    const clone = document.createElement('iframe');
                    clone.src = iframe.src;
                    clone.style.width = '100%';
                    clone.style.height = '100%';
                    clone.style.border = '0';
                    clone.className = 'map-clone';
                    // when iframe loads, hide leaflet controls inside it
                    clone.addEventListener('load', () => {
                        try {
                            const doc = clone.contentDocument || clone.contentWindow.document;
                            if (doc) {
                                const removeControls = () => {
                                    doc.querySelectorAll('.leaflet-control, #reset-btn, #clear-pins-btn, .leaflet-control-zoom, .leaflet-control-container').forEach(el => {
                                        try { el.style.display = 'none'; el.remove?.(); } catch(e) {}
                                    });
                                };
                                removeControls();
                                // in case controls are added later, observe and remove
                                try {
                                    const obs = new MutationObserver(removeControls);
                                    obs.observe(doc.body, { childList: true, subtree: true });
                                    setTimeout(() => obs.disconnect(), 3000);
                                } catch (e) {}
                            }
                            clone.contentWindow?.setGuidedModeEnabled?.(guidedModeEnabled);
                        } catch (e) {
                            console.warn('Unable to hide controls in cloned iframe minimap', e);
                        }
                    }, { once: true });

                    content.appendChild(clone);
                    return;
                } catch (e) {
                    console.warn('Failed to clone map iframe for minimap', e);
                }
            }

            const mapCard = document.querySelector('[data-card-id="map"]');
            const mapContainer = mapCard?.querySelector('.map-container');
            if (mapContainer) {
                const wrapper = document.createElement('div');
                wrapper.className = 'map-clone';
                wrapper.style.width = '100%';
                wrapper.style.height = '100%';
                wrapper.style.overflow = 'hidden';
                wrapper.innerHTML = mapContainer.innerHTML;
                // remove/hide leaflet controls in the copied HTML and watch for late additions
                const removeInlineControls = () => {
                    wrapper.querySelectorAll('.leaflet-control, #reset-btn, #clear-pins-btn, .leaflet-control-zoom, .leaflet-control-container').forEach(el => {
                        try { el.remove(); } catch (e) {}
                    });
                };
                removeInlineControls();
                try {
                    const obs = new MutationObserver(removeInlineControls);
                    obs.observe(wrapper, { childList: true, subtree: true });
                    setTimeout(() => obs.disconnect(), 3000);
                } catch (e) {}
                content.appendChild(wrapper);
            }
        }

        function hideMinimap() {
            minimapOpen = false;
            const mm = document.getElementById('minimap');
            if (mm) mm.classList.remove('open');
            const content = document.getElementById('minimap-content');
            if (content) content.querySelectorAll('iframe').forEach(n => n.remove());
        }

        function toggleMinimap() {
            if (minimapOpen) hideMinimap(); else showMinimap();
        }

        function toggleMinimapEnlarge() {
            minimapLarge = !minimapLarge;
            if (!minimapOpen) {
                showMinimap();
            }
            applyMinimapUiState();
        }

        function executeOnMinimapIframe(callback) {
            const iframe = document.querySelector('#minimap-content iframe');
            if (!iframe) return;

            if (iframe.contentDocument?.readyState === 'complete') {
                callback(iframe);
            } else {
                iframe.addEventListener('load', () => callback(iframe), { once: true });
            }
        }

        function callMapMethod(methodName, ...args) {
            executeOnIframe((iframe) => {
                setTimeout(() => {
                    const fn = iframe.contentWindow?.[methodName];
                    if (typeof fn === 'function') {
                        fn(...args);
                    }
                }, 0);
            });
        }

        function callMinimapMethod(methodName, ...args) {
            executeOnMinimapIframe((iframe) => {
                setTimeout(() => {
                    const fn = iframe.contentWindow?.[methodName];
                    if (typeof fn === 'function') {
                        fn(...args);
                    }
                }, 0);
            });
        }

        function applyMinimapUiState() {
            const minimapEl = document.getElementById('minimap');
            if (minimapEl) {
                minimapEl.classList.toggle(MINIMAP_ENLARGE_ACTIVE_CLASS, minimapLarge);
            }
            if (minimapEnlargeBtnEl) {
                minimapEnlargeBtnEl.classList.toggle('is-active', minimapLarge);
                minimapEnlargeBtnEl.setAttribute('aria-pressed', minimapLarge ? 'true' : 'false');
                minimapEnlargeBtnEl.setAttribute('aria-label', minimapLarge ? 'Unenlarge minimap' : 'Enlarge minimap');
                minimapEnlargeBtnEl.setAttribute('title', minimapLarge ? 'Unenlarge Minimap' : 'Enlarge Minimap');
            }
            applyMapGuidedToggleUI();
        }

        function fitMapToBounds() {
            callMapMethod('fitBoundsView');
        }

        function resetMapView() {
            callMapMethod('resetView');
        }

        // ===== COMMAND SUITE FUNCTIONS =====
        const COMMAND_DEFS = [
            {
                id: 'go_dark',
                label: 'Go Dark',
                type: 'toggle',
                icon: '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M21 12.4A8 8 0 1 1 11.6 3a7 7 0 0 0 9.4 9.4Z" fill="currentColor"></path></svg>'
            },
            {
                id: 'auto_rth',
                label: 'Autonomous RTH',
                type: 'toggle',
                icon: '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 3l8 6v9a1 1 0 0 1-1 1h-5v-6h-4v6H5a1 1 0 0 1-1-1V9l8-6z" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/><path d="M12 7v6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path d="M9 10l3-3 3 3" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>'
            },
            {
                id: 'drop_gps_pin',
                label: 'Drop GPS Pin',
                type: 'pulse',
                icon: '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 11C13.1046 11 14 10.1046 14 9C14 7.89543 13.1046 7 12 7C10.8954 7 10 7.89543 10 9C10 10.1046 10.8954 11 12 11Z" fill="currentColor"/><path fill-rule="evenodd" clip-rule="evenodd" d="M18 9C18 11.973 15.8377 14.441 13 14.917V20H16C16.5523 20 17 20.4477 17 21C17 21.5523 16.5523 22 16 22H8C7.44772 22 7 21.5523 7 21C7 20.4477 7.44772 20 8 20H11V14.917C8.16229 14.441 6 11.973 6 9C6 5.68629 8.68629 3 12 3C15.3137 3 18 5.68629 18 9ZM12 13C14.2091 13 16 11.2091 16 9C16 6.79086 14.2091 5 12 5C9.79086 5 8 6.79086 8 9C8 11.2091 9.79086 13 12 13Z" fill="currentColor"/></svg>'
            },
            {
                id: 'emergency',
                label: 'Emergency',
                type: 'toggle',
                icon: '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2 2 20h20L12 2Z" fill="none" stroke="currentColor" stroke-width="2"></path><path d="M12 8v6" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path><circle cx="12" cy="17" r="1.5" fill="currentColor"></circle></svg>'
            },
            {
                id: 'loiter',
                label: 'Loiter',
                type: 'toggle',
                icon: '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 5a7 7 0 1 1-6.2 3.8" fill="none" stroke="currentColor" stroke-width="2"></path><path d="M5 5v4h4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>'
            }
        ];

        const COMMAND_MINIMIZED_ORDER = [
            'go_dark',
            'auto_rth',
            'drop_gps_pin',
            'emergency',
            'loiter'
        ];

        let commandState = {};

        function getCommandDef(id) {
            return COMMAND_DEFS.find(cmd => cmd.id === id);
        }

        function buildCommandButton(def) {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'command-btn';
            // mark emergency button for targeted styling
            if (def.id === 'emergency') btn.classList.add('emergency-btn');
            btn.dataset.commandId = def.id;
            btn.dataset.commandType = def.type;
            if (def.type === 'pulse') btn.classList.add('is-pulse');
            btn.innerHTML = `<span class="command-icon">${def.icon}</span><span class="command-label">${def.label}</span>`;
            btn.setAttribute('aria-pressed', 'false');

            btn.addEventListener('click', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                await sendCommand(def);
            });
            return btn;
        }

        function buildCameraFunctionButton(def) {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'camera-function-tab';
            if (def.id === 'emergency') btn.classList.add('emergency-btn');
            btn.dataset.commandId = def.id;
            btn.dataset.commandType = def.type;
            if (def.type === 'pulse') btn.classList.add('is-pulse');
            btn.innerHTML = `<span class="camera-tab-icon">${def.icon}</span><span class="camera-tab-label">${def.label}</span>`;
            btn.setAttribute('aria-label', def.label);
            btn.setAttribute('aria-pressed', 'false');

            btn.addEventListener('click', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                await sendCommand(def);
            });
            
            return btn;
        }

        function renderCommandSuite() {
            const compactEl = document.getElementById('command-compact');
            const fullEl = document.getElementById('command-full');
            if (!compactEl || !fullEl) return;

            compactEl.innerHTML = '';
            fullEl.innerHTML = '';

            COMMAND_MINIMIZED_ORDER.forEach(id => {
                const def = getCommandDef(id);
                if (def) compactEl.appendChild(buildCommandButton(def));
            });

            COMMAND_DEFS.forEach(def => {
                fullEl.appendChild(buildCommandButton(def));
            });
        }

        function renderCameraFunctionTabs() {
            document.querySelectorAll('[data-function-rail]').forEach(rail => {
                const cameraId = rail.dataset.cameraId;
                const selectedIds = ((cameraFunctionTabs && cameraFunctionTabs[cameraId]) || [])
                    .filter(id => !CAMERA_RAIL_BLOCKED_COMMAND_IDS.has(id));
                rail.innerHTML = '';

                selectedIds.forEach(id => {
                    const def = getCommandDef(id);
                    if (def) rail.appendChild(buildCameraFunctionButton(def));
                });

                if (cameraId === 'hq') {
                    const clearTargetBtn = document.createElement('button');
                    clearTargetBtn.type = 'button';
                    clearTargetBtn.className = 'camera-function-tab rail-clear-target-tab';
                    clearTargetBtn.innerHTML = '<span class="camera-tab-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="8"></circle><path d="M12 9v3"></path><path d="M9 12h3"></path><path d="m4 4 16 16"></path></svg></span><span class="camera-tab-label">Clear Target</span>';
                    clearTargetBtn.setAttribute('aria-label', 'Clear target selection');
                    clearTargetBtn.setAttribute('aria-pressed', 'false');
                    clearTargetBtn.addEventListener('click', async (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        await clearHqTargetSelection();
                    });
                    rail.appendChild(clearTargetBtn);
                }

                // add minimap toggle into the rail so tab is part of camera rails
                const minimapBtn = document.createElement('button');
                minimapBtn.type = 'button';
                minimapBtn.className = 'camera-function-tab rail-minimap-tab';
                minimapBtn.innerHTML = '<span class="camera-tab-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z"></path><circle cx="12" cy="10" r="3"></circle></svg></span><span class="camera-tab-label">Minimap</span>';
                minimapBtn.setAttribute('aria-label', 'Minimap');
                minimapBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleMinimap(); });
                rail.appendChild(minimapBtn);

                rail.classList.toggle('is-empty', rail.children.length === 0);
            });

            applyHqTargetSelectionToUI();
        }

        function renderMapFunctionRail() {
            const rail = document.getElementById('map-function-rail');
            if (!rail) return;
            rail.innerHTML = '';

            const def = getCommandDef(MAP_RAIL_COMMAND_ID);
            if (def) rail.appendChild(buildCameraFunctionButton(def));
            applyMapGuidedToggleUI();
        }

        function setupGuidedModeToolbar() {
            if (guidedAltitudeInputEl) {
                guidedAltitudeInputEl.min = String(MAP_GUIDED_MIN_ALT_M);
                guidedAltitudeInputEl.max = String(MAP_GUIDED_MAX_ALT_M);
                guidedAltitudeInputEl.step = String(MAP_GUIDED_ALT_STEP_M);
                guidedAltitudeInputEl.value = String(guidedModeAltitudeM);

                guidedAltitudeInputEl.addEventListener('change', () => {
                    getGuidedAltitudeValue();
                });
            }

            guidedModeSwitchEl?.addEventListener('change', () => {
                setMapGuidedMode(Boolean(guidedModeSwitchEl.checked));
            });

            applyMapGuidedToggleUI();
            updateGuidedToolbarVisibility();
        }

        function setupMinimapControls() {
            minimapCenterBtnEl?.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                callMinimapMethod('resetView');
            });

            minimapClearBtnEl?.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                callMinimapMethod('clearPins');
            });

            minimapGuidedBtnEl?.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                setMapGuidedMode(!guidedModeEnabled);
            });

            minimapEnlargeBtnEl?.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                toggleMinimapEnlarge();
            });

            applyMinimapUiState();
        }

        function applyHqCvModeToUI() {
            const buttons = document.querySelectorAll('.hq-cv-mode-btn[data-hq-cv-mode]');
            buttons.forEach((btn) => {
                const isActive = btn.dataset.hqCvMode === hqCvMode;
                btn.classList.toggle('is-active', isActive);
                btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
            });
            applyHqTargetSelectionToUI();
            updateHqStreamSelectionState();
            renderHqTargetTrackingModelSelector();
            renderHqTrackingStatusLine();
        }

        function renderHqTargetTrackingModelSelector() {
            const rows = document.querySelectorAll('[data-hq-tt-model-row]');
            const selects = document.querySelectorAll('[data-hq-tt-model-select]');
            const show = hqCvMode === 'target_tracking';

            rows.forEach(row => {
                row.style.display = show ? 'inline-flex' : 'none';
            });

            selects.forEach(selectEl => {
                const existing = new Set(Array.from(selectEl.options).map(opt => opt.value));
                hqTargetTrackingModelOptions.forEach(opt => {
                    if (existing.has(opt.key)) return;
                    const optionEl = document.createElement('option');
                    optionEl.value = opt.key;
                    optionEl.textContent = opt.label;
                    selectEl.appendChild(optionEl);
                });
                if (hqTargetTrackingModelKey) {
                    selectEl.value = hqTargetTrackingModelKey;
                }
            });
        }

        function renderHqTrackingStatusLine() {
            const selectEls = document.querySelectorAll('[data-hq-tt-model-select]');
            if (!selectEls.length) return;

            const text = (hqTrackingStatusText || '').trim();
            selectEls.forEach(selectEl => {
                if (hqCvMode !== 'target_tracking') {
                    selectEl.title = '';
                    return;
                }
                selectEl.title = text;
            });
        }

        async function loadHqTargetTrackingModel() {
            try {
                const res = await fetch(HQ_TARGET_TRACKING_MODEL_ENDPOINT, { cache: 'no-store' });
                if (!res.ok) return;
                const data = await res.json();
                if (Array.isArray(data?.available_models)) {
                    hqTargetTrackingModelOptions = data.available_models
                        .filter(opt => typeof opt?.key === 'string')
                        .map(opt => ({ key: opt.key, label: String(opt?.label || opt.key) }));
                }
                if (typeof data?.selected_model_key === 'string') {
                    hqTargetTrackingModelKey = data.selected_model_key;
                }
                renderHqTargetTrackingModelSelector();
            } catch (err) {
                console.error('Failed to load HQ target tracking model:', err);
            }
        }

        async function setHqTargetTrackingModel(modelKey) {
            if (!modelKey || modelKey === hqTargetTrackingModelKey) return;
            try {
                const res = await fetch(HQ_TARGET_TRACKING_MODEL_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model_key: modelKey })
                });
                if (!res.ok) return;
                const data = await res.json();
                if (!data?.success) return;
                if (Array.isArray(data?.available_models)) {
                    hqTargetTrackingModelOptions = data.available_models
                        .filter(opt => typeof opt?.key === 'string')
                        .map(opt => ({ key: opt.key, label: String(opt?.label || opt.key) }));
                }
                if (typeof data?.selected_model_key === 'string') {
                    hqTargetTrackingModelKey = data.selected_model_key;
                }
                hqTrackingStatusText = 'Target Tracking model switched';
                renderHqTargetTrackingModelSelector();
                renderHqTrackingStatusLine();
                await refreshHqTargetTrackingStatus();
            } catch (err) {
                console.error('Failed to set HQ target tracking model:', err);
            }
        }

        async function refreshHqTargetTrackingStatus() {
            try {
                const res = await fetch(HQ_TARGET_TRACKING_STATUS_ENDPOINT, { cache: 'no-store' });
                if (!res.ok) return;
                const data = await res.json();

                if (hqCvMode !== 'target_tracking') {
                    hqTrackingStatusText = '';
                    renderHqTrackingStatusLine();
                    return;
                }

                if (Array.isArray(data?.available_models)) {
                    hqTargetTrackingModelOptions = data.available_models
                        .filter(opt => typeof opt?.key === 'string')
                        .map(opt => ({ key: opt.key, label: String(opt?.label || opt.key) }));
                }
                if (typeof data?.selected_model_key === 'string') {
                    hqTargetTrackingModelKey = data.selected_model_key;
                }
                renderHqTargetTrackingModelSelector();

                if (data?.ready) {
                    const modelPath = typeof data?.loaded_model_path === 'string' ? data.loaded_model_path : '';
                    const modelFile = modelPath ? modelPath.split('/').pop() : '';
                    const selectedLabel = typeof data?.selected_model_label === 'string' ? data.selected_model_label : hqTargetTrackingModelKey;
                    hqTrackingStatusText = modelFile
                        ? `Model ${selectedLabel}: ${modelFile}`
                        : 'Target Tracking ready';
                } else if (typeof data?.error === 'string' && data.error.trim()) {
                    hqTrackingStatusText = data.error.trim();
                } else {
                    hqTrackingStatusText = 'Target Tracking initializing...';
                }
                renderHqTrackingStatusLine();
            } catch (err) {
                console.error('Failed to refresh HQ tracking status:', err);
            }
        }

        function applyHqTargetSelectionToUI() {
            const clearButtons = document.querySelectorAll('.rail-clear-target-tab');
            const shouldShow = hqCvMode === 'target_tracking';
            clearButtons.forEach(btn => {
                btn.style.display = shouldShow ? '' : 'none';
                btn.classList.toggle('is-active', hqTargetSelected);
                btn.setAttribute('aria-pressed', hqTargetSelected ? 'true' : 'false');
                const label = hqTargetSelected && hqTargetTrackId != null
                    ? `Clear target (ID ${hqTargetTrackId})`
                    : 'Clear target selection';
                btn.setAttribute('aria-label', label);
                btn.setAttribute('title', label);
            });
        }

        function updateHqStreamSelectionState() {
            const hqCard = document.querySelector('[data-card-id="hq"]');
            const hqImg = document.getElementById('stream_hq');
            if (!hqCard || !hqImg) return;
            const canSelect = hqCvMode === 'target_tracking' && hqCard.classList.contains('expanded');
            hqImg.classList.toggle('hq-target-select-enabled', canSelect);
            hqImg.title = canSelect
                ? 'Click a detected target to lock tracking'
                : '';
        }

        async function loadHqTargetSelection() {
            try {
                const res = await fetch(HQ_TARGET_SELECTION_ENDPOINT, { cache: 'no-store' });
                if (!res.ok) return;
                const data = await res.json();
                hqTargetSelected = Boolean(data?.selected);
                hqTargetTrackId = Number.isFinite(Number(data?.track_id)) ? Number(data.track_id) : null;
                applyHqTargetSelectionToUI();
            } catch (err) {
                console.error('Failed to load HQ target selection:', err);
            }
        }

        async function clearHqTargetSelection() {
            try {
                const res = await fetch(HQ_TARGET_SELECTION_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'clear' })
                });
                if (!res.ok) return;
                const data = await res.json();
                hqTargetSelected = Boolean(data?.selected);
                hqTargetTrackId = Number.isFinite(Number(data?.track_id)) ? Number(data.track_id) : null;
                applyHqTargetSelectionToUI();
            } catch (err) {
                console.error('Failed to clear HQ target selection:', err);
            }
        }

        function getNormalizedImagePointForClick(imgEl, event) {
            if (!imgEl) return null;
            const rect = imgEl.getBoundingClientRect();
            if (!rect.width || !rect.height) return null;

            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;
            const displayW = rect.width;
            const displayH = rect.height;

            const naturalW = imgEl.naturalWidth || displayW;
            const naturalH = imgEl.naturalHeight || displayH;
            const objectFit = getComputedStyle(imgEl).objectFit || 'fill';

            let drawW = displayW;
            let drawH = displayH;
            let offsetX = 0;
            let offsetY = 0;

            if (objectFit === 'contain') {
                const scale = Math.min(displayW / naturalW, displayH / naturalH);
                drawW = naturalW * scale;
                drawH = naturalH * scale;
                offsetX = (displayW - drawW) / 2;
                offsetY = (displayH - drawH) / 2;
            } else if (objectFit === 'cover') {
                const scale = Math.max(displayW / naturalW, displayH / naturalH);
                drawW = naturalW * scale;
                drawH = naturalH * scale;
                offsetX = (displayW - drawW) / 2;
                offsetY = (displayH - drawH) / 2;
            }

            const localX = clickX - offsetX;
            const localY = clickY - offsetY;

            if (localX < 0 || localY < 0 || localX > drawW || localY > drawH) {
                return null;
            }

            const srcX = (localX / drawW) * naturalW;
            const srcY = (localY / drawH) * naturalH;
            return {
                x: Math.max(0, Math.min(1, srcX / naturalW)),
                y: Math.max(0, Math.min(1, srcY / naturalH)),
            };
        }

        function setupHqTargetSelectionInteraction() {
            const hqImg = document.getElementById('stream_hq');
            if (!hqImg) return;

            hqImg.addEventListener('click', async (e) => {
                const hqCard = document.querySelector('[data-card-id="hq"]');
                if (!hqCard?.classList.contains('expanded')) return;
                if (hqCvMode !== 'target_tracking') return;

                const point = getNormalizedImagePointForClick(hqImg, e);
                if (!point) return;

                e.preventDefault();
                e.stopPropagation();

                try {
                    const res = await fetch(HQ_TARGET_SELECTION_ENDPOINT, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ action: 'select', x_norm: point.x, y_norm: point.y })
                    });
                    const data = await res.json();
                    hqTargetSelected = Boolean(data?.selected);
                    hqTargetTrackId = Number.isFinite(Number(data?.track_id)) ? Number(data.track_id) : null;
                    applyHqTargetSelectionToUI();
                } catch (err) {
                    console.error('Failed to select HQ target:', err);
                }
            }, true);
        }

        async function loadHqCvMode() {
            try {
                const res = await fetch(HQ_CV_MODE_ENDPOINT, { cache: 'no-store' });
                if (!res.ok) return;
                const data = await res.json();
                if (typeof data?.mode === 'string') {
                    hqCvMode = data.mode;
                    applyHqCvModeToUI();
                }
            } catch (err) {
                console.error('Failed to load HQ CV mode:', err);
            }
        }

        async function setHqCvMode(nextMode) {
            if (!nextMode || nextMode === hqCvMode) return;
            try {
                const res = await fetch(HQ_CV_MODE_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: nextMode })
                });
                if (!res.ok) return;
                const data = await res.json();
                if (data?.success && typeof data?.mode === 'string') {
                    hqCvMode = data.mode;
                    applyHqCvModeToUI();
                }
            } catch (err) {
                console.error('Failed to set HQ CV mode:', err);
            }
        }

        function setupHqCvModeSwitch() {
            document.addEventListener('click', (e) => {
                const toolbar = e.target?.closest?.('[data-hq-cv-switch]');
                if (!toolbar) return;
                const modeBtn = e.target?.closest?.('.hq-cv-mode-btn[data-hq-cv-mode]');
                if (!modeBtn) return;
                e.preventDefault();
                e.stopPropagation();
                setHqCvMode(modeBtn.dataset.hqCvMode);
            }, true);

            document.addEventListener('click', (e) => {
                if (e.target?.closest?.('[data-hq-cv-switch]')) {
                    e.stopPropagation();
                }
            }, true);

            applyHqCvModeToUI();
        }

        function setupHqTargetTrackingModelSelector() {
            document.addEventListener('change', (e) => {
                const selectEl = e.target?.closest?.('[data-hq-tt-model-select]');
                if (!selectEl) return;
                e.stopPropagation();
                setHqTargetTrackingModel(selectEl.value);
            }, true);
        }

        /* Hover floating label removed — hover/tooltip UI is handled externally */

        function applyCommandStateToUI() {
            document.querySelectorAll('.command-btn, .camera-function-tab').forEach(btn => {
                const id = btn.dataset.commandId;
                if (!id) return;
                const isActive = Boolean(commandState[id]);
                btn.classList.toggle('is-active', isActive);
                btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
            });

            if (commandState.emergency) {
                document.body.classList.add('emergency-mode');
            } else {
                document.body.classList.remove('emergency-mode');
            }
        }

        async function fetchCommandState() {
            try {
                const res = await fetch('/api/commands');
                const data = await res.json();
                commandState = { ...commandState, ...data };
                applyCommandStateToUI();
            } catch (e) {
                console.error('Failed to fetch command state:', e);
            }
        }

        async function sendCommand(def) {
            const isPulse = def.type === 'pulse';
            const nextValue = isPulse ? true : !Boolean(commandState[def.id]);

            if (def.id === 'drop_gps_pin') {
                callMapMethod('dropGpsPin');
            }

            if (isPulse) {
                const buttons = document.querySelectorAll(`.command-btn[data-command-id="${def.id}"], .camera-function-tab[data-command-id="${def.id}"]`);
                buttons.forEach(btn => {
                    btn.classList.add('is-pending');
                    setTimeout(() => btn.classList.remove('is-pending'), 400);
                });
            }

            // Optimistically update toggle buttons locally for immediate feedback
            if (!isPulse) {
                commandState[def.id] = nextValue;
                applyCommandStateToUI();
            }

            try {
                const res = await fetch('/api/command', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: def.id, value: nextValue, pulse: isPulse })
                });
                const data = await res.json();
                if (data.success && data.commands) {
                    commandState = { ...commandState, ...data.commands };
                    applyCommandStateToUI();
                }
            } catch (e) {
                console.error('Failed to send command:', e);
            }
        }

        function clearExpanded() {
            restoreGuidedToolbarToBanner();
            bannerSlot.innerHTML = '';
            document.querySelectorAll('.card.expanded').forEach(c => c.classList.remove('expanded'));
            document.body.classList.remove('expanded');
            document.exitFullscreen?.().catch(() => {});
            updateMapControls();
            updateMinimapVisibility();
            updateGuidedToolbarVisibility();
            updateHqStreamSelectionState();
        }

        // ===== CARD EXPANSION HANDLERS =====
        function setupCardExpansion() {
            document.addEventListener('click', e => {
                if (e.target.closest('[data-minimize]')) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Check if we're minimizing the map card and enable follow mode
                    const card = e.target.closest('[data-card]');
                    if (card && card.getAttribute('data-card-id') === 'map') {
                        // Enable follow mode when map is minimized
                        executeOnIframe((iframe) => {
                            const win = iframe.contentWindow;
                            if (win && win.isFollowing !== undefined) {
                                win.isFollowing = true;
                            }
                        });
                    }
                    
                    clearExpanded();
                }
            }, true);

            document.querySelectorAll('[data-card]').forEach(card => {
                const header = card.querySelector('[data-header]');
                card.addEventListener('click', () => {
                    if (!card.classList.contains('expanded')) {
                        clearExpanded();
                        card.classList.add('expanded');
                        document.body.classList.add('expanded');
                        const headerClone = header.cloneNode(true);
                        headerClone.classList.add('in-banner');
                        bannerSlot.appendChild(headerClone);
                        if (card.getAttribute('data-card-id') === 'map') {
                            attachGuidedToolbarToMapHeader(headerClone);
                        } else {
                            restoreGuidedToolbarToBanner();
                        }
                        document.documentElement.requestFullscreen?.().catch(() => {});
                        updateMapControls();
                        updateMinimapVisibility();
                        updateGuidedToolbarVisibility();
                        updateHqStreamSelectionState();
                    }
                });
            });

            document.querySelector('#banner img').addEventListener('click', e => {
                e.stopPropagation();
                location.reload();
            });
        }

        // ===== LOGIN FUNCTIONS =====
        function showLoginModal() {
            loginModal.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
            document.getElementById('username').focus();
        }

        function hideLoginModal() {
            loginModal.classList.add('hidden');
            document.body.style.overflow = 'auto';
        }

        function initializeLogin() {
            const cachedToken = localStorage.getItem('sentryToken') || sessionStorage.getItem('sentryToken');
            const cachedUsername = localStorage.getItem('sentryUsername') || sessionStorage.getItem('sentryUsername');
            (cachedToken && cachedUsername) ? hideLoginModal() : showLoginModal();
        }

        function setupLoginHandlers() {
            loginForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const username = document.getElementById('username').value.trim();
                const password = document.getElementById('password').value.trim();
                const rememberMe = document.getElementById('rememberMe').checked;

                try {
                    const response = await fetch('/api/authenticate', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ username, password })
                    });

                    const data = await response.json();

                    if (data.success) {
                        sessionStorage.setItem('sentryToken', data.token);
                        sessionStorage.setItem('sentryUsername', username);
                        if (rememberMe) {
                            localStorage.setItem('sentryToken', data.token);
                            localStorage.setItem('sentryUsername', username);
                        }
                        loginForm.reset();
                        loginError.classList.add('hidden');
                        hideLoginModal();
                        loadUserSettings();
                    } else {
                        loginError.textContent = data.message || 'Invalid username or password';
                        loginError.classList.remove('hidden');
                        document.getElementById('password').value = '';
                        document.getElementById('password').focus();
                    }
                } catch (error) {
                    loginError.textContent = 'An error occurred. Please try again.';
                    loginError.classList.remove('hidden');
                    console.error('Login error:', error);
                }
            });

            settingsLogoutBtn.addEventListener('click', async () => {
                try {
                    await fetch('/api/logout', { method: 'POST' });
                } catch (error) {
                    console.error('Logout error:', error);
                }
                localStorage.removeItem('sentryToken');
                localStorage.removeItem('sentryUsername');
                sessionStorage.removeItem('sentryToken');
                sessionStorage.removeItem('sentryUsername');
                loginForm.reset();
                closeSettingsModal();
                showLoginModal();
            });
        }

        function setupSettingsHandlers() {
            buildCameraSettingsOptions();
            populateSettingsForm(userSettings);

            settingsBtn?.addEventListener('click', () => {
                populateSettingsForm(userSettings);
                openSettingsModal();
            });

            settingsCloseBtn?.addEventListener('click', closeSettingsModal);
            settingsCancelBtn?.addEventListener('click', () => {
                populateSettingsForm(userSettings);
                closeSettingsModal();
            });

            settingsReloadWsBtn?.addEventListener('click', async () => {
                const button = settingsReloadWsBtn;
                if (!button) return;
                const prevText = button.textContent;
                button.disabled = true;
                button.textContent = 'Reloading...';
                await reloadWebsocketConnections();
                button.textContent = prevText;
                button.disabled = false;
            });

            settingsModal?.addEventListener('click', (e) => {
                if (e.target === settingsModal) {
                    closeSettingsModal();
                }
            });

            settingsForm?.addEventListener('submit', async (e) => {
                e.preventDefault();
                const nextSettings = collectSettingsFromForm();
                const token = getSessionToken();
                try {
                    const res = await fetch('/api/settings', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            ...(token ? { 'X-Session-Token': token } : {})
                        },
                        body: JSON.stringify(nextSettings)
                    });
                    const data = await res.json();
                    if (data?.settings) {
                        applySettingsToUI(data.settings);
                    } else {
                        applySettingsToUI(nextSettings);
                    }
                    closeSettingsModal();
                } catch (err) {
                    console.error('Failed to save settings:', err);
                }
            });
        }

        // ===== INITIALIZATION =====
        function initialize() {
            setupCardExpansion();
            setupLoginHandlers();
            setupSettingsHandlers();
            setupGuidedModeToolbar();
            setupMinimapControls();
            setupHqCvModeSwitch();
            setupHqTargetTrackingModelSelector();
            setupHqTargetSelectionInteraction();
            window.addEventListener('message', handleGuidedMapMessage);
            updateMapControls();
            updateMinimapVisibility();
            updateGuidedToolbarVisibility();
            updateHqStreamSelectionState();
            // minimap toggle buttons are created inside each camera function rail

            applySettingsToUI(userSettings);
            renderCommandSuite();
            renderMapFunctionRail();
            loadHqCvMode();
            loadHqTargetTrackingModel();
            loadHqTargetSelection();
            refreshHqTargetTrackingStatus();
            fetchCommandState();
            setInterval(fetchCommandState, 2000);
            setInterval(loadHqTargetSelection, 1000);
            setInterval(refreshHqTargetTrackingStatus, HQ_TARGET_TRACKING_STATUS_POLL_MS);

            refreshLatencyData();
            startLatencyPolling();

            refreshMavlinkTerminal();
            startMavlinkTerminalPolling();
            
            updateStatusDots();
            startStatusPolling();
            
            initializeLogin();
            loadUserSettings();
            updateMapControls();  // Ensure map controls are properly initialized
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initialize);
        } else {
            initialize();
        }
    </script>
</body>
</html>