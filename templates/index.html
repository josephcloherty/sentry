<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Argus Dynamics - SENTRY Dashboard</title>
    <link rel="icon" type="image/x-icon" href="/images/Argus_Light.ico" media="(prefers-color-scheme: light)">
    <link rel="icon" type="image/x-icon" href="/images/Argus_Dark.ico" media="(prefers-color-scheme: dark)">
    <link rel="stylesheet" href="/styles/index.css">
</head>
<body>
    <!-- Login Modal -->
    <div id="loginModal" class="login-modal hidden">
        <div class="login-container">
            <div class="login-header">
                <div class="login-logo-container">
                    <img src="images/Argus_Light.png" alt="Argus Dynamics Logo" class="login-logo">
                </div>
                <h1>SENTRY UAS Dashboard</h1>
                <p>Please log in to continue</p>
            </div>
            <form id="loginForm" class="login-form">
                <div class="form-group">
                    <label for="username">Username</label>
                    <input type="text" id="username" name="username" placeholder="Enter username" required>
                </div>
                <div class="form-group">
                    <label for="password">Password</label>
                    <input type="password" id="password" name="password" placeholder="Enter password" required>
                </div>
                <div class="form-group checkbox">
                    <input type="checkbox" id="rememberMe" name="rememberMe">
                    <label for="rememberMe">Remember me</label>
                </div>
                <button type="submit" class="login-button">Sign In</button>
                <div id="loginError" class="login-error hidden"></div>
            </form>
        </div>
    </div>
    <div id="banner">
        <div class="banner-left">
            <img src="images/Argus_Dark.png" alt="Argus Dynamics Logo">
            <h1>SENTRY UAS Dashboard</h1>
        </div>
        <div class="banner-right">
            <div class="main-status">
                <span id="main-status-dot" class="status-dot {{ 'on' if main_online else 'off' }}"></span>
                <span>System Status</span>
            </div>
            <div id="banner-slot"></div>
            <button id="logoutBtn" class="logout-button">
                <img src="images/logout_white.png" alt="Logout" class="logout-logo">
            </button>
        </div>
    </div>

    <div class="grid">
        <div class="card" data-card data-card-id="cam0">
            <div class="card-header" data-header>
                <span id="cam0-status-dot" class="status-dot {{ 'on' if cam0_online else 'off' }}"></span>
                <h2>Pilot Camera</h2>
                <button class="minimize" data-minimize>Minimize</button>
            </div>
            <div class="media">
                <img id="stream_cam0" src="{{ url_for('video_feed_cam0') }}">
            </div>
            <div class="desc">Front facing camera for BVLOS piloting</div>
        </div>

        <div class="card" data-card data-card-id="cam1">
            <div class="card-header" data-header>
                <span id="cam1-status-dot" class="status-dot {{ 'on' if cam1_online else 'off' }}"></span>
                <h2>Landing Camera</h2>
                <button class="minimize" data-minimize>Minimize</button>
            </div>
            <div class="media">
                <img id="stream_cam1" src="{{ url_for('video_feed_cam1') }}">
            </div>
            <div class="desc">Infrared camera for landing assistance</div>
        </div>

        <div class="card" data-card data-card-id="hq">
            <div class="card-header" data-header>
                <span id="hq-status-dot" class="status-dot {{ 'on' if hq_online else 'off' }}"></span>
                <h2>High Quality Camera</h2>
                <button class="minimize" data-minimize>Minimize</button>
            </div>
            <div class="media empty">
                <div class="placeholder">EMPTY</div>
            </div>
            <div class="desc">High Quality camera for detailed imaging (Gimbal)</div>
        </div>

        <div class="card" data-card data-card-id="map">
            <div class="card-header" data-header>
                <span id="map-status-dot" class="status-dot {{ 'on' if map_online else 'off' }}"></span>
                <h2>GPS Map</h2>
                <button class="minimize" data-minimize>Minimize</button>
            </div>
            <div class="media_map">
                <div class="map-container">{{ map_html|safe }}</div>
            </div>
            <div class="desc_map">GPS Location of SENTRY</div>
        </div>

        <div class="card latency-card" data-card data-card-id="latency">
            <div class="card-header" data-header>
                <span id="latency-status-dot" class="status-dot off"></span>
                <h2>Latency Monitoring</h2>
                <button class="minimize" data-minimize>Minimize</button>
            </div>
            <div class="media latency-content">
                <div class="latency-dashboard">
                    <div class="latency-section">
                        <h3>Pilot Camera (cam0)</h3>
                        <div class="latency-metrics">
                            <div class="latency-row">
                                <span class="latency-label">Network:</span>
                                <span id="cam0-network-latency" class="latency-value">--</span>
                                <span class="latency-unit">ms</span>
                            </div>
                            <div class="latency-row">
                                <span class="latency-label">Render:</span>
                                <span id="cam0-render-latency" class="latency-value">--</span>
                                <span class="latency-unit">ms</span>
                            </div>
                            <div class="latency-row total">
                                <span class="latency-label">Total E2E:</span>
                                <span id="cam0-total-latency" class="latency-value">--</span>
                                <span class="latency-unit">ms</span>
                            </div>
                        </div>
                        <div class="latency-bar-container">
                            <div id="cam0-latency-bar" class="latency-bar"></div>
                        </div>
                    </div>
                    <div class="latency-section">
                        <h3>Landing Camera (cam1)</h3>
                        <div class="latency-metrics">
                            <div class="latency-row">
                                <span class="latency-label">Network:</span>
                                <span id="cam1-network-latency" class="latency-value">--</span>
                                <span class="latency-unit">ms</span>
                            </div>
                            <div class="latency-row">
                                <span class="latency-label">Render:</span>
                                <span id="cam1-render-latency" class="latency-value">--</span>
                                <span class="latency-unit">ms</span>
                            </div>
                            <div class="latency-row total">
                                <span class="latency-label">Total E2E:</span>
                                <span id="cam1-total-latency" class="latency-value">--</span>
                                <span class="latency-unit">ms</span>
                            </div>
                        </div>
                        <div class="latency-bar-container">
                            <div id="cam1-latency-bar" class="latency-bar"></div>
                        </div>
                    </div>
                    <!-- MAVLink telemetry card (latency only, with bar) -->
                    <div class="latency-section">
                        <h3>MAVLink Telemetry</h3>
                        <div class="latency-metrics">
                            <div class="latency-row">
                                <span class="latency-label">Latency:</span>
                                <span id="mavlink-latency" class="latency-value">--</span>
                                <span class="latency-unit">ms</span>
                            </div>
                        </div>
                        <div class="latency-bar-container">
                            <div id="mavlink-latency-bar" class="latency-bar"></div>
                        </div>
                    </div>
                    <div class="latency-stats">
                        <div class="stat-item">
                            <span class="stat-label">Update Rate:</span>
                            <span id="latency-update-rate" class="stat-value">--</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Last Update:</span>
                            <span id="latency-last-update" class="stat-value">--</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="desc">End-to-end video latency monitoring</div>
        </div>

        <div class="card command-card" data-card data-card-id="commands">
            <div class="card-header" data-header>
                <span id="commands-status-dot" class="status-dot on"></span>
                <h2>Function Suite</h2>
                <button class="minimize" data-minimize>Minimize</button>
            </div>
            <div class="media command-suite">
                <div class="command-grid compact-view" id="command-compact"></div>
                <div class="command-grid full-view" id="command-full"></div>
            </div>
            <div class="desc">Command switches for onboard functions and mission actions</div>
        </div>
    </div>

    <!-- Minimap tab (left) and minimap overlay (bottom-right) -->
    <div id="minimap-tab" class="minimap-tab" aria-hidden="true">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z"></path><circle cx="12" cy="10" r="3"></circle></svg>
    </div>

    <div id="minimap" class="minimap" aria-hidden="true">
        <div class="minimap-bar" id="minimap-bar"></div>
        <div class="minimap-content" id="minimap-content">
            <!-- iframe cloned here when available; no text per design -->
        </div>
    </div>

    <script>
        // ===== GLOBAL CONFIGURATION =====
        const LATENCY_UPDATE_INTERVAL_MS = 2000;
        const STATUS_UPDATE_INTERVAL_MS = 30000;
        
        // ===== GLOBAL DOM ELEMENTS =====
        const bannerSlot = document.getElementById('banner-slot');
        const loginModal = document.getElementById('loginModal');
        const loginForm = document.getElementById('loginForm');
        const loginError = document.getElementById('loginError');
        const logoutBtn = document.getElementById('logoutBtn');
        
        // ===== GLOBAL STATE =====
        let videoLatencyData = {
            cam0_network_latency_ms: 0,
            cam1_network_latency_ms: 0,
            cam0_render_latency_ms: 0,
            cam1_render_latency_ms: 0,
            cam0_total_latency_ms: 0,
            cam1_total_latency_ms: 0
        };
        let telemetryData = {};
        let telemetryLatencyMs = 0;
        let cam0FrameLoadTime = 0;
        let cam1FrameLoadTime = 0;
        let cam0FrameRenderTime = 0;
        let cam1FrameRenderTime = 0;

        // ===== HELPER FUNCTIONS =====
        function getLatencyClass(latencyMs) {
            if (latencyMs <= 0) return '';
            if (latencyMs < 100) return 'good';
            if (latencyMs < 250) return 'warning';
            return 'critical';
        }

        function updateStatusDot(elementId, isOnline) {
            const dot = document.getElementById(elementId);
            if (!dot) return;
            dot.classList.remove('on', 'off');
            dot.classList.add(isOnline ? 'on' : 'off');
        }

        function updateLatencyValue(elementId, value, applyClass = false) {
            const el = document.getElementById(elementId);
            if (!el) return;
            el.textContent = value > 0 ? value.toFixed(1) : '--';
            if (applyClass) {
                el.className = 'latency-value ' + getLatencyClass(value);
            }
        }

        function updateLatencyBar(elementId, latencyMs, maxMs = 500) {
            const el = document.getElementById(elementId);
            if (!el) return;
            const barWidth = Math.min(100, (latencyMs / maxMs) * 100);
            el.style.width = barWidth + '%';
        }

        // ===== VIDEO LATENCY FUNCTIONS =====
        function measureRenderLatency() {
            if (cam0FrameLoadTime > 0 && cam0FrameRenderTime > 0) {
                videoLatencyData.cam0_render_latency_ms = Math.max(0, cam0FrameRenderTime - cam0FrameLoadTime);
            }
            if (cam1FrameLoadTime > 0 && cam1FrameRenderTime > 0) {
                videoLatencyData.cam1_render_latency_ms = Math.max(0, cam1FrameRenderTime - cam1FrameLoadTime);
            }
        }
        
        function setupImageLoadTracking() {
            const setupCameraTracking = (camId) => {
                const img = document.getElementById(`stream_${camId}`);
                if (!img) return;
                
                img.addEventListener('load', () => {
                    if (camId === 'cam0') {
                        cam0FrameLoadTime = performance.now();
                        requestAnimationFrame(() => cam0FrameRenderTime = performance.now());
                    } else {
                        cam1FrameLoadTime = performance.now();
                        requestAnimationFrame(() => cam1FrameRenderTime = performance.now());
                    }
                });
            };
            
            setupCameraTracking('cam0');
            setupCameraTracking('cam1');
        }
        
        function updateLatencyDisplay() {
            // Calculate totals
            videoLatencyData.cam0_total_latency_ms = videoLatencyData.cam0_network_latency_ms + videoLatencyData.cam0_render_latency_ms;
            videoLatencyData.cam1_total_latency_ms = videoLatencyData.cam1_network_latency_ms + videoLatencyData.cam1_render_latency_ms;
            
            // Update cam0
            updateLatencyValue('cam0-network-latency', videoLatencyData.cam0_network_latency_ms, true);
            updateLatencyValue('cam0-render-latency', videoLatencyData.cam0_render_latency_ms);
            updateLatencyValue('cam0-total-latency', videoLatencyData.cam0_total_latency_ms, true);
            updateLatencyBar('cam0-latency-bar', videoLatencyData.cam0_total_latency_ms);
            
            // Update cam1
            updateLatencyValue('cam1-network-latency', videoLatencyData.cam1_network_latency_ms, true);
            updateLatencyValue('cam1-render-latency', videoLatencyData.cam1_render_latency_ms);
            updateLatencyValue('cam1-total-latency', videoLatencyData.cam1_total_latency_ms, true);
            updateLatencyBar('cam1-latency-bar', videoLatencyData.cam1_total_latency_ms);
            
            // Update stats
            const updateRateEl = document.getElementById('latency-update-rate');
            const lastUpdateEl = document.getElementById('latency-last-update');
            if (updateRateEl) updateRateEl.textContent = LATENCY_UPDATE_INTERVAL_MS + 'ms';
            if (lastUpdateEl) lastUpdateEl.textContent = new Date().toLocaleTimeString();
            
            // Update status dot
            const hasData = videoLatencyData.cam0_network_latency_ms > 0 || videoLatencyData.cam1_network_latency_ms > 0 || telemetryLatencyMs > 0;
            updateStatusDot('latency-status-dot', hasData);

            // Update MAVLink telemetry latency display and bar
            updateLatencyValue('mavlink-latency', telemetryLatencyMs || 0, true);
            updateLatencyBar('mavlink-latency-bar', telemetryLatencyMs || 0);
        }
        
        function fetchVideoLatency() {
            fetch('/api/video_latency')
                .then(response => response.json())
                .then(data => {
                    videoLatencyData.cam0_network_latency_ms = data.cam0_network_latency_ms || 0;
                    videoLatencyData.cam1_network_latency_ms = data.cam1_network_latency_ms || 0;
                    measureRenderLatency();
                    updateLatencyDisplay();
                })
                .catch(err => console.error('Failed to fetch video latency:', err));
        }
        
        // ===== STATUS UPDATE FUNCTIONS =====
        function updateStatusDots() {
            fetch('/api/status')
                .then(response => response.json())
                .then(status => {
                    updateStatusDot('main-status-dot', status.main_online);
                    updateStatusDot('cam0-status-dot', status.cam0_online);
                    updateStatusDot('cam1-status-dot', status.cam1_online);
                    updateStatusDot('hq-status-dot', status.hq_online);
                    updateStatusDot('map-status-dot', status.map_online);
                })
                .catch(err => console.error('Failed to fetch status:', err));
        }
        
        // ===== TELEMETRY WEBSOCKET FUNCTIONS =====
        
        function connectTelemetryWebSocket() {
            const urls = [
                'ws://100.112.223.17:8764',
                `ws://localhost:8888`
            ];
            let urlIndex = 0;
            let reconnectAttempts = 0;
            const maxReconnectAttempts = 3;
            
            function attemptConnection() {
                console.log(`Attempting to connect to ${urls[urlIndex]} (attempt ${reconnectAttempts + 1})`);
                
                const telemetryWs = new WebSocket(urls[urlIndex]);
                const connectionTimeout = setTimeout(() => {
                    console.warn(`Connection timeout for ${urls[urlIndex]}`);
                    telemetryWs.close();
                }, 3000);
                
                telemetryWs.onopen = () => {
                    clearTimeout(connectionTimeout);
                    console.log(`✓ Connected to telemetry at ${urls[urlIndex]}`);
                    reconnectAttempts = 0;
                };
                
                telemetryWs.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        telemetryData = data;
                        
                        const clientTime = Date.now() / 1000;
                        const roundTripLatency = (clientTime - data.timestamp) * 1000;
                        telemetryLatencyMs = roundTripLatency + (data.server_latency_ms || 0);
                        
                        if (Math.random() < 0.01) {
                            console.log(`[Telemetry] Latency: ${telemetryLatencyMs.toFixed(1)}ms (client: ${roundTripLatency.toFixed(1)}ms + server: ${(data.server_latency_ms || 0).toFixed(1)}ms)`);
                        }
                    } catch (e) {
                        console.error('Failed to parse telemetry data:', e);
                    }
                };
                
                telemetryWs.onerror = (error) => {
                    clearTimeout(connectionTimeout);
                    console.error(`WebSocket error for ${urls[urlIndex]}:`, error);
                };
                
                telemetryWs.onclose = () => {
                    clearTimeout(connectionTimeout);
                    console.log(`✗ Connection closed for ${urls[urlIndex]}`);
                    
                    reconnectAttempts++;
                    if (reconnectAttempts >= maxReconnectAttempts) {
                        console.log('Max attempts reached, trying next URL');
                        urlIndex++;
                        reconnectAttempts = 0;
                        
                        if (urlIndex >= urls.length) {
                            console.log('All telemetry URLs exhausted, restarting from first URL');
                            urlIndex = 0;
                        }
                    }
                    
                    setTimeout(attemptConnection, 1000);
                };
            }
            
            setTimeout(attemptConnection, 300);
        }
        
        // ===== MAP CONTROL FUNCTIONS =====
        
        function getMapIframe() {
            const mapCard = document.querySelector('[data-card-id="map"]');
            return mapCard?.querySelector('iframe');
        }

        function executeOnIframe(callback) {
            const iframe = getMapIframe();
            if (!iframe) return;

            if (iframe.contentDocument?.readyState === 'complete') {
                callback(iframe);
            } else {
                iframe.addEventListener('load', () => callback(iframe), { once: true });
            }
        }

        function updateMapControls() {
            executeOnIframe((iframe) => {
                const doc = iframe.contentDocument || iframe.contentWindow?.document;
                if (!doc) return;
                
                const mapCard = document.querySelector('[data-card-id="map"]');
                const isExpanded = mapCard?.classList.contains('expanded');
                
                doc.querySelectorAll('.leaflet-control').forEach(el => {
                    el.style.display = isExpanded ? '' : 'none';
                });
                
                const resetBtn = doc.getElementById('reset-btn');
                if (resetBtn) resetBtn.style.display = isExpanded ? 'block' : 'none';
            });
        }

        // ===== MINIMAP (small persistent map) =====
        let minimapOpen = false;

        function updateMinimapVisibility() {
            const expandedCard = document.querySelector('.card.expanded');
            const showTab = expandedCard && ['cam0', 'cam1', 'hq'].includes(expandedCard.getAttribute('data-card-id'));
            const tab = document.getElementById('minimap-tab');
            if (tab) tab.style.display = showTab ? 'flex' : 'none';
            if (!showTab) {
                minimapOpen = false;
                const mm = document.getElementById('minimap');
                if (mm) mm.classList.remove('open');
                const content = document.getElementById('minimap-content');
                if (content) content.querySelectorAll('iframe').forEach(n => n.remove());
            }
        }

        function showMinimap() {
            minimapOpen = true;
            const mm = document.getElementById('minimap');
            if (mm) mm.classList.add('open');

            const content = document.getElementById('minimap-content');
            if (!content) return;
            content.querySelectorAll('iframe, .map-clone').forEach(n => n.remove());

            const iframe = getMapIframe();
            if (iframe && iframe.src) {
                try {
                    const clone = document.createElement('iframe');
                    clone.src = iframe.src;
                    clone.style.width = '100%';
                    clone.style.height = '100%';
                    clone.style.border = '0';
                    clone.className = 'map-clone';
                    // when iframe loads, hide leaflet controls inside it
                    clone.addEventListener('load', () => {
                        try {
                            const doc = clone.contentDocument || clone.contentWindow.document;
                            if (doc) {
                                const removeControls = () => {
                                    doc.querySelectorAll('.leaflet-control, #reset-btn, .leaflet-control-zoom, .leaflet-control-container').forEach(el => {
                                        try { el.style.display = 'none'; el.remove?.(); } catch(e) {}
                                    });
                                };
                                removeControls();
                                // in case controls are added later, observe and remove
                                try {
                                    const obs = new MutationObserver(removeControls);
                                    obs.observe(doc.body, { childList: true, subtree: true });
                                    setTimeout(() => obs.disconnect(), 3000);
                                } catch (e) {}
                            }
                        } catch (e) {
                            console.warn('Unable to hide controls in cloned iframe minimap', e);
                        }
                    }, { once: true });

                    content.appendChild(clone);
                    return;
                } catch (e) {
                    console.warn('Failed to clone map iframe for minimap', e);
                }
            }

            const mapCard = document.querySelector('[data-card-id="map"]');
            const mapContainer = mapCard?.querySelector('.map-container');
            if (mapContainer) {
                const wrapper = document.createElement('div');
                wrapper.className = 'map-clone';
                wrapper.style.width = '100%';
                wrapper.style.height = '100%';
                wrapper.style.overflow = 'hidden';
                wrapper.innerHTML = mapContainer.innerHTML;
                // remove/hide leaflet controls in the copied HTML and watch for late additions
                const removeInlineControls = () => {
                    wrapper.querySelectorAll('.leaflet-control, #reset-btn, .leaflet-control-zoom, .leaflet-control-container').forEach(el => {
                        try { el.remove(); } catch (e) {}
                    });
                };
                removeInlineControls();
                try {
                    const obs = new MutationObserver(removeInlineControls);
                    obs.observe(wrapper, { childList: true, subtree: true });
                    setTimeout(() => obs.disconnect(), 3000);
                } catch (e) {}
                content.appendChild(wrapper);
            }
        }

        function hideMinimap() {
            minimapOpen = false;
            const mm = document.getElementById('minimap');
            if (mm) mm.classList.remove('open');
            const content = document.getElementById('minimap-content');
            if (content) content.querySelectorAll('iframe').forEach(n => n.remove());
        }

        function toggleMinimap() {
            if (minimapOpen) hideMinimap(); else showMinimap();
        }

        function callMapMethod(methodName) {
            executeOnIframe((iframe) => {
                setTimeout(() => iframe.contentWindow?.[methodName]?.(), 0);
            });
        }

        function fitMapToBounds() {
            callMapMethod('fitBoundsView');
        }

        function resetMapView() {
            callMapMethod('resetView');
        }

        // ===== COMMAND SUITE FUNCTIONS =====
        const COMMAND_DEFS = [
            {
                id: 'go_dark',
                label: 'Go Dark',
                type: 'toggle',
                icon: '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M21 12.4A8 8 0 1 1 11.6 3a7 7 0 0 0 9.4 9.4Z" fill="currentColor"></path></svg>'
            },
            {
                id: 'night_vision',
                label: 'Night Vision Mode',
                type: 'toggle',
                icon: '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6Z" fill="none" stroke="currentColor" stroke-width="2"></path><circle cx="12" cy="12" r="3" fill="currentColor"></circle></svg>'
            },
            {
                id: 'auto_rth',
                label: 'Autonomous RTH',
                type: 'toggle',
                icon: '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 12l9-9 9 9" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M9 21V9h6v12" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>'
            },
            {
                id: 'drop_gps_pin',
                label: 'Drop GPS Pin',
                type: 'pulse',
                icon: '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 21s-6-6-6-11a6 6 0 0 1 12 0c0 5-6 11-6 11Z" fill="none" stroke="currentColor" stroke-width="2"></path><circle cx="12" cy="10" r="2" fill="currentColor"></circle></svg>'
            },
            {
                id: 'emergency',
                label: 'Emergency',
                type: 'toggle',
                icon: '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2 2 20h20L12 2Z" fill="none" stroke="currentColor" stroke-width="2"></path><path d="M12 8v6" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path><circle cx="12" cy="17" r="1.5" fill="currentColor"></circle></svg>'
            },
            {
                id: 'loiter',
                label: 'Loiter',
                type: 'toggle',
                icon: '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 5a7 7 0 1 1-6.2 3.8" fill="none" stroke="currentColor" stroke-width="2"></path><path d="M5 5v4h4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>'
            },
            {
                id: 'landing_mode',
                label: 'Landing Mode',
                type: 'pulse',
                icon: '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 3v12" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path><path d="M7 10l5 5 5-5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M4 21h16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path></svg>'
            }
        ];

        const COMMAND_MINIMIZED_ORDER = [
            'go_dark',
            'night_vision',
            'auto_rth',
            'drop_gps_pin',
            'emergency',
            'loiter'
        ];

        let commandState = {};

        function getCommandDef(id) {
            return COMMAND_DEFS.find(cmd => cmd.id === id);
        }

        function buildCommandButton(def) {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'command-btn';
            btn.dataset.commandId = def.id;
            btn.dataset.commandType = def.type;
            if (def.type === 'pulse') btn.classList.add('is-pulse');
            btn.innerHTML = `<span class="command-icon">${def.icon}</span><span class="command-label">${def.label}</span>`;
            btn.setAttribute('aria-pressed', 'false');

            btn.addEventListener('click', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                await sendCommand(def);
            });
            return btn;
        }

        function renderCommandSuite() {
            const compactEl = document.getElementById('command-compact');
            const fullEl = document.getElementById('command-full');
            if (!compactEl || !fullEl) return;

            compactEl.innerHTML = '';
            fullEl.innerHTML = '';

            COMMAND_MINIMIZED_ORDER.forEach(id => {
                const def = getCommandDef(id);
                if (def) compactEl.appendChild(buildCommandButton(def));
            });

            COMMAND_DEFS.forEach(def => {
                fullEl.appendChild(buildCommandButton(def));
            });
        }

        function applyCommandStateToUI() {
            document.querySelectorAll('.command-btn').forEach(btn => {
                const id = btn.dataset.commandId;
                const isActive = Boolean(commandState[id]);
                btn.classList.toggle('is-active', isActive);
                btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
            });

            if (commandState.emergency) {
                document.body.classList.add('emergency-mode');
            } else {
                document.body.classList.remove('emergency-mode');
            }
        }

        async function fetchCommandState() {
            try {
                const res = await fetch('/api/commands');
                const data = await res.json();
                commandState = { ...commandState, ...data };
                applyCommandStateToUI();
            } catch (e) {
                console.error('Failed to fetch command state:', e);
            }
        }

        async function sendCommand(def) {
            const isPulse = def.type === 'pulse';
            const nextValue = isPulse ? true : !Boolean(commandState[def.id]);

            if (isPulse) {
                const btn = document.querySelector(`.command-btn[data-command-id="${def.id}"]`);
                if (btn) {
                    btn.classList.add('is-pending');
                    setTimeout(() => btn.classList.remove('is-pending'), 400);
                }
            }

            try {
                const res = await fetch('/api/command', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: def.id, value: nextValue, pulse: isPulse })
                });
                const data = await res.json();
                if (data.success && data.commands) {
                    commandState = { ...commandState, ...data.commands };
                    applyCommandStateToUI();
                }
            } catch (e) {
                console.error('Failed to send command:', e);
            }
        }

        function clearExpanded() {
            bannerSlot.innerHTML = '';
            document.querySelectorAll('.card.expanded').forEach(c => c.classList.remove('expanded'));
            document.body.classList.remove('expanded');
            document.exitFullscreen?.().catch(() => {});
            updateMapControls();
            updateMinimapVisibility();
        }

        // ===== CARD EXPANSION HANDLERS =====
        function setupCardExpansion() {
            document.addEventListener('click', e => {
                if (e.target.closest('[data-minimize]')) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Check if we're minimizing the map card and enable follow mode
                    const card = e.target.closest('[data-card]');
                    if (card && card.getAttribute('data-card-id') === 'map') {
                        // Enable follow mode when map is minimized
                        executeOnIframe((iframe) => {
                            const win = iframe.contentWindow;
                            if (win && win.isFollowing !== undefined) {
                                win.isFollowing = true;
                            }
                        });
                    }
                    
                    clearExpanded();
                }
            }, true);

            document.querySelectorAll('[data-card]').forEach(card => {
                const header = card.querySelector('[data-header]');
                card.addEventListener('click', () => {
                    if (!card.classList.contains('expanded')) {
                        clearExpanded();
                        card.classList.add('expanded');
                        document.body.classList.add('expanded');
                        const headerClone = header.cloneNode(true);
                        headerClone.classList.add('in-banner');
                        bannerSlot.appendChild(headerClone);
                        document.documentElement.requestFullscreen?.().catch(() => {});
                        updateMapControls();
                            updateMinimapVisibility();
                    }
                });
            });

            document.querySelector('#banner img').addEventListener('click', e => {
                e.stopPropagation();
                location.reload();
            });
        }

        // ===== LOGIN FUNCTIONS =====
        function showLoginModal() {
            loginModal.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
            document.getElementById('username').focus();
        }

        function hideLoginModal() {
            loginModal.classList.add('hidden');
            document.body.style.overflow = 'auto';
        }

        function initializeLogin() {
            const cachedToken = localStorage.getItem('sentryToken');
            const cachedUsername = localStorage.getItem('sentryUsername');
            (cachedToken && cachedUsername) ? hideLoginModal() : showLoginModal();
        }

        function setupLoginHandlers() {
            loginForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const username = document.getElementById('username').value.trim();
                const password = document.getElementById('password').value.trim();
                const rememberMe = document.getElementById('rememberMe').checked;

                try {
                    const response = await fetch('/api/authenticate', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ username, password })
                    });

                    const data = await response.json();

                    if (data.success) {
                        if (rememberMe) {
                            localStorage.setItem('sentryToken', data.token);
                            localStorage.setItem('sentryUsername', username);
                        }
                        loginForm.reset();
                        loginError.classList.add('hidden');
                        hideLoginModal();
                    } else {
                        loginError.textContent = data.message || 'Invalid username or password';
                        loginError.classList.remove('hidden');
                        document.getElementById('password').value = '';
                        document.getElementById('password').focus();
                    }
                } catch (error) {
                    loginError.textContent = 'An error occurred. Please try again.';
                    loginError.classList.remove('hidden');
                    console.error('Login error:', error);
                }
            });

            logoutBtn.addEventListener('click', async () => {
                try {
                    await fetch('/api/logout', { method: 'POST' });
                } catch (error) {
                    console.error('Logout error:', error);
                }
                localStorage.removeItem('sentryToken');
                localStorage.removeItem('sentryUsername');
                loginForm.reset();
                showLoginModal();
            });
        }

        // ===== INITIALIZATION =====
        function initialize() {
            setupImageLoadTracking();
            setupCardExpansion();
            setupLoginHandlers();
            updateMapControls();
            updateMinimapVisibility();
            // wire minimap UI (tab toggles open/close)
            const tab = document.getElementById('minimap-tab');
            if (tab) tab.addEventListener('click', (e) => { e.stopPropagation(); toggleMinimap(); });

            renderCommandSuite();
            fetchCommandState();
            setInterval(fetchCommandState, 2000);
            
            connectTelemetryWebSocket();
            
            setInterval(fetchVideoLatency, LATENCY_UPDATE_INTERVAL_MS);
            fetchVideoLatency();
            
            setInterval(updateStatusDots, STATUS_UPDATE_INTERVAL_MS);
            updateStatusDots();
            
            initializeLogin();
            updateMapControls();  // Ensure map controls are properly initialized
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initialize);
        } else {
            initialize();
        }
    </script>
</body>
</html>