<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Argus Dynamics - SENTRY Dashboard</title>
    <link rel="icon" type="image/x-icon" href="/images/Argus_Light.ico" media="(prefers-color-scheme: light)">
    <link rel="icon" type="image/x-icon" href="/images/Argus_Dark.ico" media="(prefers-color-scheme: dark)">
    <link rel="stylesheet" href="/styles/index.css">
</head>
<body>
    <!-- Login Modal -->
    <div id="loginModal" class="login-modal hidden">
        <div class="login-container">
            <div class="login-header">
                <div class="login-logo-container">
                    <img src="images/Argus_Light.png" alt="Argus Dynamics Logo" class="login-logo">
                </div>
                <h1>SENTRY UAS Dashboard</h1>
                <p>Please log in to continue</p>
            </div>
            <form id="loginForm" class="login-form">
                <div class="form-group">
                    <label for="username">Username</label>
                    <input type="text" id="username" name="username" placeholder="Enter username" required>
                </div>
                <div class="form-group">
                    <label for="password">Password</label>
                    <input type="password" id="password" name="password" placeholder="Enter password" required>
                </div>
                <div class="form-group checkbox">
                    <input type="checkbox" id="rememberMe" name="rememberMe">
                    <label for="rememberMe">Remember me</label>
                </div>
                <button type="submit" class="login-button">Sign In</button>
                <div id="loginError" class="login-error hidden"></div>
            </form>
        </div>
    </div>
    <div id="banner">
        <div class="banner-left">
            <img src="images/Argus_Dark.png" alt="Argus Dynamics Logo">
            <h1>SENTRY UAS Dashboard</h1>
        </div>
        <div class="banner-right">
            <div class="main-status">
                <span id="main-status-dot" class="status-dot {{ 'on' if main_online else 'off' }}"></span>
                <span>System Status</span>
            </div>
            <div id="banner-slot"></div>
            <button id="logoutBtn" class="logout-button">
                <img src="images/logout_white.png" alt="Logout" class="logout-logo">
            </button>
        </div>
    </div>

    <div class="grid">
        <div class="card" data-card data-card-id="cam0">
            <div class="card-header" data-header>
                <span id="cam0-status-dot" class="status-dot {{ 'on' if cam0_online else 'off' }}"></span>
                <h2>Pilot Camera</h2>
                <button class="minimize" data-minimize>Minimize</button>
            </div>
            <div class="media">
                <img id="stream_cam0" src="{{ url_for('video_feed_cam0') }}">
            </div>
            <div class="desc">Front facing camera for BVLOS piloting</div>
        </div>

        <div class="card" data-card data-card-id="cam1">
            <div class="card-header" data-header>
                <span id="cam1-status-dot" class="status-dot {{ 'on' if cam1_online else 'off' }}"></span>
                <h2>Landing Camera</h2>
                <button class="minimize" data-minimize>Minimize</button>
            </div>
            <div class="media">
                <img id="stream_cam1" src="{{ url_for('video_feed_cam1') }}">
            </div>
            <div class="desc">Infrared camera for landing assistance</div>
        </div>

        <div class="card" data-card data-card-id="hq">
            <div class="card-header" data-header>
                <span id="hq-status-dot" class="status-dot {{ 'on' if hq_online else 'off' }}"></span>
                <h2>High Quality Camera</h2>
                <button class="minimize" data-minimize>Minimize</button>
            </div>
            <div class="media empty">
                <div class="placeholder">EMPTY</div>
            </div>
            <div class="desc">High Quality camera for detailed imaging (Gimbal)</div>
        </div>

        <div class="card" data-card data-card-id="map">
            <div class="card-header" data-header>
                <span id="map-status-dot" class="status-dot {{ 'on' if map_online else 'off' }}"></span>
                <h2>GPS Map</h2>
                <button class="minimize" data-minimize>Minimize</button>
            </div>
            <div class="media_map">
                <div class="map-container">{{ map_html|safe }}</div>
            </div>
            <div class="desc_map">GPS Location of SENTRY</div>
        </div>

        <div class="card latency-card" data-card data-card-id="latency">
            <div class="card-header" data-header>
                <span id="latency-status-dot" class="status-dot off"></span>
                <h2>Video Latency</h2>
                <button class="minimize" data-minimize>Minimize</button>
            </div>
            <div class="media latency-content">
                <div class="latency-dashboard">
                    <div class="latency-section">
                        <h3>Pilot Camera (cam0)</h3>
                        <div class="latency-metrics">
                            <div class="latency-row">
                                <span class="latency-label">Network:</span>
                                <span id="cam0-network-latency" class="latency-value">--</span>
                                <span class="latency-unit">ms</span>
                            </div>
                            <div class="latency-row">
                                <span class="latency-label">Render:</span>
                                <span id="cam0-render-latency" class="latency-value">--</span>
                                <span class="latency-unit">ms</span>
                            </div>
                            <div class="latency-row total">
                                <span class="latency-label">Total E2E:</span>
                                <span id="cam0-total-latency" class="latency-value">--</span>
                                <span class="latency-unit">ms</span>
                            </div>
                        </div>
                        <div class="latency-bar-container">
                            <div id="cam0-latency-bar" class="latency-bar"></div>
                        </div>
                    </div>
                    <div class="latency-section">
                        <h3>Landing Camera (cam1)</h3>
                        <div class="latency-metrics">
                            <div class="latency-row">
                                <span class="latency-label">Network:</span>
                                <span id="cam1-network-latency" class="latency-value">--</span>
                                <span class="latency-unit">ms</span>
                            </div>
                            <div class="latency-row">
                                <span class="latency-label">Render:</span>
                                <span id="cam1-render-latency" class="latency-value">--</span>
                                <span class="latency-unit">ms</span>
                            </div>
                            <div class="latency-row total">
                                <span class="latency-label">Total E2E:</span>
                                <span id="cam1-total-latency" class="latency-value">--</span>
                                <span class="latency-unit">ms</span>
                            </div>
                        </div>
                        <div class="latency-bar-container">
                            <div id="cam1-latency-bar" class="latency-bar"></div>
                        </div>
                    </div>
                    <div class="latency-stats">
                        <div class="stat-item">
                            <span class="stat-label">Update Rate:</span>
                            <span id="latency-update-rate" class="stat-value">--</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Last Update:</span>
                            <span id="latency-last-update" class="stat-value">--</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="desc">End-to-end video latency monitoring</div>
        </div>
    </div>

    <script>
        const bannerSlot = document.getElementById('banner-slot');
        
        // ===== Configuration =====
        const LATENCY_UPDATE_INTERVAL_MS = 2000;  // How often to poll video latency (milliseconds)
        const STATUS_UPDATE_INTERVAL_MS = 30000;   // How often to poll connection status (milliseconds)
        
        // ===== VIDEO LATENCY MEASUREMENT =====
        let videoLatencyData = {
            cam0_network_latency_ms: 0,
            cam1_network_latency_ms: 0,
            cam0_render_latency_ms: 0,
            cam1_render_latency_ms: 0,
            cam0_total_latency_ms: 0,
            cam1_total_latency_ms: 0
        };
        let latencyUpdateCount = 0;
        let lastLatencyUpdateTime = Date.now();
        let cam0LastFrameTime = 0;
        let cam1LastFrameTime = 0;
        
        // Track render latency by observing when frames are displayed
        function measureRenderLatency() {
            const cam0Img = document.getElementById('stream_cam0');
            const cam1Img = document.getElementById('stream_cam1');
            
            // Use frame timestamps to estimate render delay
            // The browser adds ~16-33ms (1-2 frames at 60fps) for rendering
            const ESTIMATED_BROWSER_RENDER_MS = 16;
            videoLatencyData.cam0_render_latency_ms = ESTIMATED_BROWSER_RENDER_MS;
            videoLatencyData.cam1_render_latency_ms = ESTIMATED_BROWSER_RENDER_MS;
        }
        
        function updateLatencyDisplay() {
            const cam0NetworkEl = document.getElementById('cam0-network-latency');
            const cam0RenderEl = document.getElementById('cam0-render-latency');
            const cam0TotalEl = document.getElementById('cam0-total-latency');
            const cam0BarEl = document.getElementById('cam0-latency-bar');
            
            const cam1NetworkEl = document.getElementById('cam1-network-latency');
            const cam1RenderEl = document.getElementById('cam1-render-latency');
            const cam1TotalEl = document.getElementById('cam1-total-latency');
            const cam1BarEl = document.getElementById('cam1-latency-bar');
            
            const updateRateEl = document.getElementById('latency-update-rate');
            const lastUpdateEl = document.getElementById('latency-last-update');
            const statusDotEl = document.getElementById('latency-status-dot');
            
            // Calculate totals
            videoLatencyData.cam0_total_latency_ms = videoLatencyData.cam0_network_latency_ms + videoLatencyData.cam0_render_latency_ms;
            videoLatencyData.cam1_total_latency_ms = videoLatencyData.cam1_network_latency_ms + videoLatencyData.cam1_render_latency_ms;
            
            // Update cam0 display
            if (cam0NetworkEl) {
                const networkVal = videoLatencyData.cam0_network_latency_ms;
                cam0NetworkEl.textContent = networkVal > 0 ? networkVal.toFixed(1) : '--';
                cam0NetworkEl.className = 'latency-value ' + getLatencyClass(networkVal);
            }
            if (cam0RenderEl) {
                cam0RenderEl.textContent = videoLatencyData.cam0_render_latency_ms.toFixed(1);
            }
            if (cam0TotalEl) {
                const totalVal = videoLatencyData.cam0_total_latency_ms;
                cam0TotalEl.textContent = totalVal > 0 ? totalVal.toFixed(1) : '--';
                cam0TotalEl.className = 'latency-value ' + getLatencyClass(totalVal);
            }
            if (cam0BarEl) {
                // Scale bar: 0-500ms maps to 0-100%
                const barWidth = Math.min(100, (videoLatencyData.cam0_total_latency_ms / 500) * 100);
                cam0BarEl.style.width = barWidth + '%';
            }
            
            // Update cam1 display
            if (cam1NetworkEl) {
                const networkVal = videoLatencyData.cam1_network_latency_ms;
                cam1NetworkEl.textContent = networkVal > 0 ? networkVal.toFixed(1) : '--';
                cam1NetworkEl.className = 'latency-value ' + getLatencyClass(networkVal);
            }
            if (cam1RenderEl) {
                cam1RenderEl.textContent = videoLatencyData.cam1_render_latency_ms.toFixed(1);
            }
            if (cam1TotalEl) {
                const totalVal = videoLatencyData.cam1_total_latency_ms;
                cam1TotalEl.textContent = totalVal > 0 ? totalVal.toFixed(1) : '--';
                cam1TotalEl.className = 'latency-value ' + getLatencyClass(totalVal);
            }
            if (cam1BarEl) {
                const barWidth = Math.min(100, (videoLatencyData.cam1_total_latency_ms / 500) * 100);
                cam1BarEl.style.width = barWidth + '%';
            }
            
            // Update stats
            if (updateRateEl) {
                updateRateEl.textContent = LATENCY_UPDATE_INTERVAL_MS + 'ms';
            }
            if (lastUpdateEl) {
                lastUpdateEl.textContent = new Date().toLocaleTimeString();
            }
            
            // Update status dot - green if any camera is providing data
            if (statusDotEl) {
                const hasData = videoLatencyData.cam0_network_latency_ms > 0 || videoLatencyData.cam1_network_latency_ms > 0;
                statusDotEl.classList.remove('on', 'off');
                statusDotEl.classList.add(hasData ? 'on' : 'off');
            }
        }
        
        function getLatencyClass(latencyMs) {
            if (latencyMs <= 0) return '';
            if (latencyMs < 100) return 'good';
            if (latencyMs < 250) return 'warning';
            return 'critical';
        }
        
        function fetchVideoLatency() {
            fetch('/api/video_latency')
                .then(response => response.json())
                .then(data => {
                    // Capture the moment we receive the API response
                    const receiveTime = Date.now() / 1000;
                    
                    // Network latency from server
                    videoLatencyData.cam0_network_latency_ms = data.cam0_network_latency_ms || 0;
                    videoLatencyData.cam1_network_latency_ms = data.cam1_network_latency_ms || 0;
                    
                    // Measure render latency
                    measureRenderLatency();
                    
                    // Update display
                    latencyUpdateCount++;
                    lastLatencyUpdateTime = Date.now();
                    updateLatencyDisplay();
                })
                .catch(err => {
                    console.error('Failed to fetch video latency:', err);
                });
        }
        
        // Poll video latency at configured interval
        setInterval(fetchVideoLatency, LATENCY_UPDATE_INTERVAL_MS);
        fetchVideoLatency(); // Initial fetch
        
        // ===== TELEMETRY WEBSOCKET CONNECTION =====
        let telemetryData = {};
        let telemetryLatencyMs = 0;
        
        function connectTelemetryWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const telemetryWs = new WebSocket(`${protocol}//${window.location.hostname}:8764`);
            
            telemetryWs.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    telemetryData = data;
                    
                    // Calculate round-trip latency (including server-side latency)
                    const clientTime = Date.now() / 1000;
                    const serverTime = data.timestamp;
                    const roundTripLatency = (clientTime - serverTime) * 1000;
                    telemetryLatencyMs = roundTripLatency + (data.server_latency_ms || 0);
                    
                    // Log latency periodically
                    if (Math.random() < 0.01) { // 1% of messages
                        console.log(`[Telemetry] Latency: ${telemetryLatencyMs.toFixed(1)}ms (client: ${roundTripLatency.toFixed(1)}ms + server: ${(data.server_latency_ms || 0).toFixed(1)}ms)`);
                    }
                } catch (e) {
                    console.error('Failed to parse telemetry data:', e);
                }
            };
            
            telemetryWs.onerror = (error) => {
                console.error('Telemetry WebSocket error:', error);
            };
            
            telemetryWs.onopen = () => {
                console.log('Telemetry WebSocket connected');
            };
            
            telemetryWs.onclose = () => {
                console.warn('Telemetry WebSocket disconnected, attempting to reconnect in 2 seconds...');
                setTimeout(connectTelemetryWebSocket, 2000);
            };
        }
        
        // Connect to telemetry WebSocket
        connectTelemetryWebSocket();
        
        // ===== STATUS UPDATE FUNCTION =====
        function updateStatusDots() {
            fetch('/api/status')
                .then(response => response.json())
                .then(status => {
                    // Update all status dots
                    const mainDot = document.getElementById('main-status-dot');
                    const cam0Dot = document.getElementById('cam0-status-dot');
                    const cam1Dot = document.getElementById('cam1-status-dot');
                    const hqDot = document.getElementById('hq-status-dot');
                    const mapDot = document.getElementById('map-status-dot');
                    
                    if (mainDot) {
                        mainDot.classList.remove('on', 'off');
                        mainDot.classList.add(status.main_online ? 'on' : 'off');
                    }
                    if (cam0Dot) {
                        cam0Dot.classList.remove('on', 'off');
                        cam0Dot.classList.add(status.cam0_online ? 'on' : 'off');
                    }
                    if (cam1Dot) {
                        cam1Dot.classList.remove('on', 'off');
                        cam1Dot.classList.add(status.cam1_online ? 'on' : 'off');
                    }
                    if (hqDot) {
                        hqDot.classList.remove('on', 'off');
                        hqDot.classList.add(status.hq_online ? 'on' : 'off');
                    }
                    if (mapDot) {
                        mapDot.classList.remove('on', 'off');
                        mapDot.classList.add(status.map_online ? 'on' : 'off');
                    }
                })
                .catch(err => console.error('Failed to fetch status:', err));
        }
        
        // Update status at configured interval
        setInterval(updateStatusDots, STATUS_UPDATE_INTERVAL_MS);
        updateStatusDots(); // Initial update
        
        const updateMapControls = () => {
            const mapCard = document.querySelector('[data-card-id="map"]');
            const iframe = mapCard?.querySelector('iframe');
            if (!mapCard || !iframe) return;

            const apply = () => {
                const doc = iframe.contentDocument || iframe.contentWindow?.document;
                if (!doc) return;
                const isExpanded = mapCard.classList.contains('expanded');
                
                // Hide leaflet controls when not expanded
                doc.querySelectorAll('.leaflet-control').forEach(el => {
                    el.style.display = isExpanded ? '' : 'none';
                });
                
                // Show/hide reset button
                const resetBtn = doc.getElementById('reset-btn');
                if (resetBtn) {
                    resetBtn.style.display = isExpanded ? 'block' : 'none';
                }
            };

            if (iframe.contentDocument?.readyState === 'complete') {
                apply();
            } else {
                iframe.addEventListener('load', apply, { once: true });
            }
        };

        const fitMapToBounds = () => {
            const mapCard = document.querySelector('[data-card-id="map"]');
            const iframe = mapCard?.querySelector('iframe');
            const mapWin = iframe?.contentWindow;
            if (!mapWin) return;

            const doFit = () => mapWin.fitBoundsView?.();
            if (iframe?.contentDocument?.readyState === 'complete') {
                setTimeout(doFit, 0);
            } else {
                iframe?.addEventListener('load', () => setTimeout(doFit, 0), { once: true });
            }
        };

        const resetMapView = () => {
            const mapCard = document.querySelector('[data-card-id="map"]');
            const iframe = mapCard?.querySelector('iframe');
            const mapWin = iframe?.contentWindow;
            if (!mapWin) return;

            const doReset = () => mapWin.resetView?.();
            if (iframe?.contentDocument?.readyState === 'complete') {
                setTimeout(doReset, 0);
            } else {
                iframe?.addEventListener('load', () => setTimeout(doReset, 0), { once: true });
            }
        };

        const clearExpanded = () => {
            bannerSlot.innerHTML = '';
            document.querySelectorAll('.card.expanded').forEach(c => c.classList.remove('expanded'));
            document.body.classList.remove('expanded');
            document.exitFullscreen?.().catch(() => {});
            updateMapControls();
        };

        // Handle minimize button clicks first with capturing phase
        document.addEventListener('click', e => {
            if (e.target.closest('[data-minimize]')) {
                e.preventDefault();
                e.stopPropagation();
                clearExpanded();
                return;
            }
        }, true);

        document.querySelectorAll('[data-card]').forEach(card => {
            const header = card.querySelector('[data-header]');
            card.addEventListener('click', e => {
                if (!card.classList.contains('expanded')) {
                    clearExpanded();
                    card.classList.add('expanded');
                    document.body.classList.add('expanded');
                    const headerClone = header.cloneNode(true);
                    headerClone.classList.add('in-banner');
                    bannerSlot.appendChild(headerClone);
                    document.documentElement.requestFullscreen?.().catch(() => {});
                    updateMapControls();
                }
            });
        });
        document.querySelector('#banner img').addEventListener('click', e => {
            e.stopPropagation();
            location.reload();
        });

        // Initial setup for map controls
        updateMapControls();

        // ===== LOGIN SYSTEM =====
        const loginModal = document.getElementById('loginModal');
        const loginForm = document.getElementById('loginForm');
        const loginError = document.getElementById('loginError');
        const logoutBtn = document.getElementById('logoutBtn');
        const usernameInput = document.getElementById('username');
        const passwordInput = document.getElementById('password');
        const rememberMeCheckbox = document.getElementById('rememberMe');

        // Check if user is already logged in
        function initializeLogin() {
            const cachedToken = localStorage.getItem('sentryToken');
            const cachedUsername = localStorage.getItem('sentryUsername');
            
            if (cachedToken && cachedUsername) {
                // User is already logged in
                hideLoginModal();
            } else {
                // User needs to log in
                showLoginModal();
            }
        }

        function showLoginModal() {
            loginModal.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
            usernameInput.focus();
        }

        function hideLoginModal() {
            loginModal.classList.add('hidden');
            document.body.style.overflow = 'auto';
        }

        // Handle login form submission
        loginForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const username = usernameInput.value.trim();
            const password = passwordInput.value.trim();
            const rememberMe = rememberMeCheckbox.checked;

            try {
                const response = await fetch('/api/authenticate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ username, password })
                });

                const data = await response.json();

                if (data.success) {
                    // Store credentials if remember me is checked
                    if (rememberMe) {
                        localStorage.setItem('sentryToken', data.token);
                        localStorage.setItem('sentryUsername', username);
                    }
                    
                    // Clear form
                    loginForm.reset();
                    loginError.classList.add('hidden');
                    
                    // Hide login modal
                    hideLoginModal();
                } else {
                    // Show error message
                    loginError.textContent = data.message || 'Invalid username or password';
                    loginError.classList.remove('hidden');
                    passwordInput.value = '';
                    passwordInput.focus();
                }
            } catch (error) {
                loginError.textContent = 'An error occurred. Please try again.';
                loginError.classList.remove('hidden');
                console.error('Login error:', error);
            }
        });

        // Handle logout
        logoutBtn.addEventListener('click', async () => {
            try {
                await fetch('/api/logout', { method: 'POST' });
            } catch (error) {
                console.error('Logout error:', error);
            }
            
            // Clear stored credentials
            localStorage.removeItem('sentryToken');
            localStorage.removeItem('sentryUsername');
            
            // Show login modal
            loginForm.reset();
            showLoginModal();
        });

        // Initialize login on page load
        document.addEventListener('DOMContentLoaded', initializeLogin);
        
        // Also run immediately in case DOM is already loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeLogin);
        } else {
            initializeLogin();
        }
    </script>
</body>
</html>